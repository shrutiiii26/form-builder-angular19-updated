{"ast":null,"code":"import _asyncToGenerator from \"D:/form-builder-angular19-updated/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let WorkerService = /*#__PURE__*/(() => {\n  class WorkerService {\n    /**\n     * Evaluate a rule condition (returns boolean). Accepts either a string condition or\n     * a parsed AST depending on usage. Returns a Promise<boolean> for compatibility\n     * with async worker-based evaluation.\n     */\n    evaluateIf(condition, context) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        // If worker is available, post a message and wait for response\n        if (_this.worker) {\n          return new Promise(resolve => {\n            const sub = _this.messages$.subscribe(msg => {\n              if (msg.type === 'EVALUATE_RULE_RESULT') {\n                sub.unsubscribe();\n                resolve(Boolean(msg.result));\n              } else if (msg.type === 'ERROR') {\n                sub.unsubscribe();\n                resolve(false);\n              }\n            });\n            _this.postMessage({\n              type: 'EVALUATE_RULE',\n              payload: {\n                condition,\n                context\n              }\n            });\n          });\n        }\n        // Fallback: evaluate on main thread\n        try {\n          return _this.evaluateRule(condition, context);\n        } catch {\n          return false;\n        }\n      })();\n    }\n    constructor() {\n      this.messageSubject = new Subject();\n      this.messages$ = this.messageSubject.asObservable();\n      if (typeof Worker !== 'undefined') {\n        try {\n          this.worker = new Worker(new URL('../../workers/expression.worker', import.meta.url), {\n            type: 'module'\n          });\n          this.worker.onmessage = ({\n            data\n          }) => {\n            this.messageSubject.next(data);\n          };\n          this.worker.onerror = error => {\n            console.error('Worker error:', error);\n            this.messageSubject.next({\n              type: 'ERROR',\n              result: null,\n              error: error.message\n            });\n          };\n        } catch (e) {\n          console.warn('Web Worker not available:', e);\n        }\n      } else {\n        console.warn('Web Workers are not supported in this environment.');\n      }\n    }\n    postMessage(message) {\n      if (this.worker) {\n        this.worker.postMessage(message);\n      } else {\n        // Fallback: compute on main thread\n        this.computeOnMainThread(message);\n      }\n    }\n    computeOnMainThread(message) {\n      try {\n        let result;\n        if (message.type === 'COMPUTE') {\n          result = this.evaluateExpression(message.payload.expr, message.payload.context);\n        } else if (message.type === 'EVALUATE_RULE') {\n          result = this.evaluateRule(message.payload.condition, message.payload.context);\n        }\n        this.messageSubject.next({\n          type: message.type + '_RESULT',\n          result\n        });\n      } catch (error) {\n        this.messageSubject.next({\n          type: 'ERROR',\n          result: null,\n          error: error.message\n        });\n      }\n    }\n    evaluateExpression(expr, context) {\n      // Simple expression evaluator - replace field IDs with values\n      let expression = expr;\n      for (const [key, value] of Object.entries(context)) {\n        const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n        expression = expression.replace(regex, String(value));\n      }\n      // Basic math evaluation (simplified - in production use a proper parser)\n      try {\n        return Function(`\"use strict\"; return (${expression})`)();\n      } catch {\n        return null;\n      }\n    }\n    evaluateRule(condition, context) {\n      // Simple rule evaluator\n      let expression = condition;\n      for (const [key, value] of Object.entries(context)) {\n        const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n        const val = typeof value === 'string' ? `'${value}'` : String(value);\n        expression = expression.replace(regex, val);\n      }\n      try {\n        return Boolean(Function(`\"use strict\"; return (${expression})`)());\n      } catch {\n        return false;\n      }\n    }\n    /**\n     * Evaluate a computed expression. Returns an object with success and result to\n     * match the expectations in runtime.component.ts\n     */\n    evaluateCompute(expr, context) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (_this2.worker) {\n          return new Promise(resolve => {\n            const sub = _this2.messages$.subscribe(msg => {\n              if (msg.type === 'COMPUTE_RESULT') {\n                sub.unsubscribe();\n                resolve({\n                  success: true,\n                  result: msg.result\n                });\n              } else if (msg.type === 'ERROR') {\n                sub.unsubscribe();\n                resolve({\n                  success: false,\n                  result: null\n                });\n              }\n            });\n            _this2.postMessage({\n              type: 'COMPUTE',\n              payload: {\n                expr,\n                context\n              }\n            });\n          });\n        }\n        try {\n          const result = _this2.evaluateExpression(expr, context);\n          return {\n            success: true,\n            result\n          };\n        } catch (err) {\n          return {\n            success: false,\n            result: null\n          };\n        }\n      })();\n    }\n    terminate() {\n      if (this.worker) {\n        this.worker.terminate();\n      }\n    }\n    static {\n      this.ɵfac = function WorkerService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || WorkerService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: WorkerService,\n        factory: WorkerService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return WorkerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}