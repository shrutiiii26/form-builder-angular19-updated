{"ast":null,"code":"import { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let WorkerService = /*#__PURE__*/(() => {\n  class WorkerService {\n    constructor() {\n      this.messageSubject = new Subject();\n      this.messages$ = this.messageSubject.asObservable();\n      if (typeof Worker !== 'undefined') {\n        try {\n          this.worker = new Worker(new URL('../../workers/expression.worker', import.meta.url), {\n            type: 'module'\n          });\n          this.worker.onmessage = ({\n            data\n          }) => {\n            this.messageSubject.next(data);\n          };\n          this.worker.onerror = error => {\n            console.error('Worker error:', error);\n            this.messageSubject.next({\n              type: 'ERROR',\n              result: null,\n              error: error.message\n            });\n          };\n        } catch (e) {\n          console.warn('Web Worker not available:', e);\n        }\n      } else {\n        console.warn('Web Workers are not supported in this environment.');\n      }\n    }\n    postMessage(message) {\n      if (this.worker) {\n        this.worker.postMessage(message);\n      } else {\n        // Fallback: compute on main thread\n        this.computeOnMainThread(message);\n      }\n    }\n    computeOnMainThread(message) {\n      try {\n        let result;\n        if (message.type === 'COMPUTE') {\n          result = this.evaluateExpression(message.payload.expr, message.payload.context);\n        } else if (message.type === 'EVALUATE_RULE') {\n          result = this.evaluateRule(message.payload.condition, message.payload.context);\n        }\n        this.messageSubject.next({\n          type: message.type + '_RESULT',\n          result\n        });\n      } catch (error) {\n        this.messageSubject.next({\n          type: 'ERROR',\n          result: null,\n          error: error.message\n        });\n      }\n    }\n    evaluateExpression(expr, context) {\n      // Simple expression evaluator - replace field IDs with values\n      let expression = expr;\n      for (const [key, value] of Object.entries(context)) {\n        const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n        expression = expression.replace(regex, String(value));\n      }\n      // Basic math evaluation (simplified - in production use a proper parser)\n      try {\n        return Function(`\"use strict\"; return (${expression})`)();\n      } catch {\n        return null;\n      }\n    }\n    evaluateRule(condition, context) {\n      // Simple rule evaluator\n      let expression = condition;\n      for (const [key, value] of Object.entries(context)) {\n        const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n        const val = typeof value === 'string' ? `'${value}'` : String(value);\n        expression = expression.replace(regex, val);\n      }\n      try {\n        return Boolean(Function(`\"use strict\"; return (${expression})`)());\n      } catch {\n        return false;\n      }\n    }\n    terminate() {\n      if (this.worker) {\n        this.worker.terminate();\n      }\n    }\n    static {\n      this.ɵfac = function WorkerService_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || WorkerService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: WorkerService,\n        factory: WorkerService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return WorkerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}