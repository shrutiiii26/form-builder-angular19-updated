{"ast":null,"code":"import _asyncToGenerator from \"D:/form-builder-angular19-updated/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ActivatedRoute } from '@angular/router';\nimport { FormGroup, FormControl, Validators } from '@angular/forms';\nimport { IndexedDBService } from '../core/services/indexeddb.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"../core/services/indexeddb.service\";\n// Beginner-style: avoid rxjs operators/subjects for simplicity\nexport let RuntimeComponent = /*#__PURE__*/(() => {\n  class RuntimeComponent {\n    constructor(route, db) {\n      this.route = route;\n      this.db = db;\n      this.fg = new FormGroup({});\n      this.currentPageIndex = 0;\n      this.hiddenFields = {};\n    }\n    ngOnInit() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const id = _this.route.snapshot.paramMap.get('id') || 'form-1';\n        yield _this.loadForm(id);\n      })();\n    }\n    ngOnDestroy() {\n      // Beginner-style: no explicit cleanup for subscriptions\n    }\n    loadForm(id) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        const forms = yield _this2.db.getAllForms();\n        _this2.formSchema = forms.find(f => f.id === id);\n        if (!_this2.formSchema && forms.length > 0) {\n          _this2.formSchema = forms[0];\n        }\n        if (_this2.formSchema) {\n          _this2.buildForm();\n          _this2.setupRulesAndComputed();\n        }\n      })();\n    }\n    buildForm() {\n      const controls = {};\n      // Build controls for all pages\n      this.formSchema.schema.pages.forEach(page => {\n        page.elements.forEach(el => {\n          const validators = this.getValidators(el);\n          const defaultValue = this.getDefaultValue(el);\n          controls[el.id] = new FormControl({\n            value: defaultValue,\n            disabled: el.disabled\n          }, validators);\n        });\n      });\n      this.fg = new FormGroup(controls);\n    }\n    getValidators(element) {\n      const validators = [];\n      if (element.required) {\n        validators.push(Validators.required);\n      }\n      if (element.validators) {\n        if (element.validators.minLength) {\n          validators.push(Validators.minLength(element.validators.minLength));\n        }\n        if (element.validators.maxLength) {\n          validators.push(Validators.maxLength(element.validators.maxLength));\n        }\n        if (element.validators.min !== undefined) {\n          validators.push(Validators.min(element.validators.min));\n        }\n        if (element.validators.max !== undefined) {\n          validators.push(Validators.max(element.validators.max));\n        }\n        if (element.validators.pattern) {\n          validators.push(Validators.pattern(element.validators.pattern));\n        }\n      }\n      return validators;\n    }\n    getDefaultValue(element) {\n      if (element.type === 'checkbox') {\n        return false;\n      }\n      if (element.type === 'number') {\n        return null;\n      }\n      return element.default || '';\n    }\n    setupRulesAndComputed() {\n      this.fg.valueChanges.subscribe(values => {\n        this.evaluateRules(values);\n        this.evaluateComputed(values);\n      });\n      // Initial evaluation\n      this.evaluateRules(this.fg.value);\n      this.evaluateComputed(this.fg.value);\n    }\n    evaluateRules(values) {\n      if (!this.formSchema.schema.rules || this.formSchema.schema.rules.length === 0) {\n        return;\n      }\n      this.formSchema.schema.rules.forEach(rule => {\n        try {\n          // Evaluate condition\n          let condition = rule.if;\n          // // Replace field references with actual values\n          // Object.keys(values).forEach(key => {\n          //   const value = values[key];\n          //   const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n          //   const replacement = typeof value === 'string' ? `'${value}'` : String(value);\n          //   condition = condition.replace(regex, replacement);\n          // });\n          // Evaluate the condition\n          const result = this.safeEvaluate(condition);\n          // Apply actions\n          if (rule.then && Array.isArray(rule.then)) {\n            rule.then.forEach(action => {\n              this.applyAction(action, result);\n            });\n          }\n        } catch (error) {\n          console.error('Error evaluating rule:', rule, error);\n        }\n      });\n    }\n    safeEvaluate(expression) {\n      try {\n        return Boolean(Function(`'use strict'; return (${expression})`)());\n      } catch {\n        return false;\n      }\n    }\n    applyAction(action, conditionResult) {\n      const control = this.fg.get(action.target);\n      if (!control) return;\n      switch (action.action) {\n        case 'show':\n          this.hiddenFields[action.target] = !conditionResult;\n          break;\n        case 'hide':\n          this.hiddenFields[action.target] = conditionResult;\n          break;\n        case 'enable':\n          if (conditionResult) {\n            control.enable();\n          }\n          break;\n        case 'disable':\n          if (conditionResult) {\n            control.disable();\n          }\n          break;\n        case 'setValue':\n          if (conditionResult && action.value !== undefined) {\n            control.setValue(action.value, {\n              emitEvent: false\n            });\n          }\n          break;\n      }\n    }\n    evaluateComputed(values) {\n      if (!this.formSchema.schema.computed || this.formSchema.schema.computed.length === 0) {\n        return;\n      }\n      this.formSchema.schema.computed.forEach(computed => {\n        try {\n          let expression = computed.expr;\n          // Replace field references with actual values\n          Object.keys(values).forEach(key => {\n            const value = values[key] || 0;\n            const regex = new RegExp(`\\\\b${key}\\\\b`, 'g');\n            expression = expression.replace(regex, String(value));\n          });\n          // Evaluate the expression\n          const result = this.safeEvaluateExpression(expression);\n          // Set the computed value\n          const control = this.fg.get(computed.target);\n          if (control) {\n            control.setValue(result, {\n              emitEvent: false\n            });\n          }\n        } catch (error) {\n          console.error('Error evaluating computed field:', computed, error);\n        }\n      });\n    }\n    safeEvaluateExpression(expression) {\n      try {\n        return Function(`'use strict'; return (${expression})`)();\n      } catch {\n        return null;\n      }\n    }\n    nextPage() {\n      if (this.currentPageIndex < this.formSchema.schema.pages.length - 1) {\n        this.currentPageIndex++;\n        window.scrollTo({\n          top: 0,\n          behavior: 'smooth'\n        });\n      }\n    }\n    previousPage() {\n      if (this.currentPageIndex > 0) {\n        this.currentPageIndex--;\n        window.scrollTo({\n          top: 0,\n          behavior: 'smooth'\n        });\n      }\n    }\n    saveDraft() {\n      localStorage.setItem(`form-draft-${this.formSchema.id}`, JSON.stringify({\n        values: this.fg.value,\n        pageIndex: this.currentPageIndex,\n        savedAt: new Date().toISOString()\n      }));\n      alert('Draft saved locally!');\n    }\n    loadDraft() {\n      const draftKey = `form-draft-${this.formSchema.id}`;\n      const draft = localStorage.getItem(draftKey);\n      if (draft) {\n        try {\n          const {\n            values,\n            pageIndex\n          } = JSON.parse(draft);\n          this.fg.patchValue(values);\n          this.currentPageIndex = pageIndex || 0;\n        } catch (error) {\n          console.error('Error loading draft:', error);\n        }\n      }\n    }\n    submit() {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        if (_this3.fg.invalid) {\n          _this3.markAllAsTouched();\n          alert('Please fill in all required fields correctly.');\n          return;\n        }\n        const submission = {\n          id: 's-' + Date.now(),\n          formId: _this3.formSchema.id,\n          formVersion: _this3.formSchema.version,\n          data: _this3.fg.value,\n          createdAt: new Date().toISOString()\n        };\n        try {\n          yield _this3.db.saveSubmission(submission);\n          // Clear draft\n          localStorage.removeItem(`form-draft-${_this3.formSchema.id}`);\n          alert('Form submitted successfully! Submission ID: ' + submission.id);\n          // Reset form\n          _this3.fg.reset();\n          _this3.currentPageIndex = 0;\n        } catch (error) {\n          console.error('Error submitting form:', error);\n          alert('Error submitting form. Please try again.');\n        }\n      })();\n    }\n    markAllAsTouched() {\n      Object.keys(this.fg.controls).forEach(key => {\n        this.fg.get(key)?.markAsTouched();\n      });\n    }\n    onFileChange(event, fieldId) {\n      const file = event.target.files[0];\n      if (file) {\n        // For this demo, store file name only\n        // In production, you'd handle file upload properly\n        const control = this.fg.get(fieldId);\n        if (control) {\n          control.setValue(file.name);\n        }\n      }\n    }\n    static {\n      this.ɵfac = function RuntimeComponent_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || RuntimeComponent)(i0.ɵɵdirectiveInject(i1.ActivatedRoute), i0.ɵɵdirectiveInject(i2.IndexedDBService));\n      };\n    }\n    static {\n      this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n        type: RuntimeComponent,\n        selectors: [[\"app-runtime\"]],\n        decls: 0,\n        vars: 0,\n        template: function RuntimeComponent_Template(rf, ctx) {},\n        styles: [\".runtime-container[_ngcontent-%COMP%]{padding:16px;background:#f7f7f7;min-height:100vh}.runtime-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}.runtime-content[_ngcontent-%COMP%]{max-width:900px;margin:0 auto}.runtime-form[_ngcontent-%COMP%]{background:#fff;border:1px solid #ddd;padding:16px}.page-title[_ngcontent-%COMP%]{margin:0 0 16px;padding-bottom:8px;border-bottom:1px solid #eee}.form-fields[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:12px}.form-field.hidden[_ngcontent-%COMP%]{display:none}.field-wrapper[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:6px}.field-label[_ngcontent-%COMP%]{font-weight:600}.required[_ngcontent-%COMP%]{color:#dc3545}.form-control[_ngcontent-%COMP%]{width:100%;padding:8px;border:1px solid #ccc;border-radius:4px;box-sizing:border-box}.radio-group[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:6px}.radio-label[_ngcontent-%COMP%], .checkbox-label[_ngcontent-%COMP%]{display:flex;align-items:center;gap:6px}.error-message[_ngcontent-%COMP%]{color:#dc3545;font-size:.9rem}.form-navigation[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;margin-top:16px;padding-top:12px;border-top:1px solid #eee}.btn[_ngcontent-%COMP%]{padding:6px 12px;border:1px solid #ccc;background:#f7f7f7;cursor:pointer}.btn-primary[_ngcontent-%COMP%]{background:#4a90e2;color:#fff;border-color:#4a90e2}.btn-secondary[_ngcontent-%COMP%]{background:#6c757d;color:#fff;border-color:#6c757d}.btn-success[_ngcontent-%COMP%]{background:#28a745;color:#fff;border-color:#28a745}.btn-info[_ngcontent-%COMP%]{background:#17a2b8;color:#fff;border-color:#17a2b8}@media (max-width: 600px){.runtime-header[_ngcontent-%COMP%], .form-navigation[_ngcontent-%COMP%]{flex-direction:column;gap:8px}.btn[_ngcontent-%COMP%]{width:100%}}\"]\n      });\n    }\n  }\n  return RuntimeComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}