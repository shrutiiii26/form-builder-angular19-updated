{"ast":null,"code":"const e = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : global,\n  t = Object.keys,\n  n = Array.isArray;\nfunction r(e, n) {\n  return \"object\" != typeof n || t(n).forEach(function (t) {\n    e[t] = n[t];\n  }), e;\n}\n\"undefined\" == typeof Promise || e.Promise || (e.Promise = Promise);\nconst s = Object.getPrototypeOf,\n  i = {}.hasOwnProperty;\nfunction o(e, t) {\n  return i.call(e, t);\n}\nfunction a(e, n) {\n  \"function\" == typeof n && (n = n(s(e))), (\"undefined\" == typeof Reflect ? t : Reflect.ownKeys)(n).forEach(t => {\n    l(e, t, n[t]);\n  });\n}\nconst u = Object.defineProperty;\nfunction l(e, t, n, s) {\n  u(e, t, r(n && o(n, \"get\") && \"function\" == typeof n.get ? {\n    get: n.get,\n    set: n.set,\n    configurable: !0\n  } : {\n    value: n,\n    configurable: !0,\n    writable: !0\n  }, s));\n}\nfunction c(e) {\n  return {\n    from: function (t) {\n      return e.prototype = Object.create(t.prototype), l(e.prototype, \"constructor\", e), {\n        extend: a.bind(null, e.prototype)\n      };\n    }\n  };\n}\nconst h = Object.getOwnPropertyDescriptor;\nfunction d(e, t) {\n  let n;\n  return h(e, t) || (n = s(e)) && d(n, t);\n}\nconst f = [].slice;\nfunction p(e, t, n) {\n  return f.call(e, t, n);\n}\nfunction y(e, t) {\n  return t(e);\n}\nfunction m(e) {\n  if (!e) throw new Error(\"Assertion Failed\");\n}\nfunction v(t) {\n  e.setImmediate ? setImmediate(t) : setTimeout(t, 0);\n}\nfunction g(e, t) {\n  return e.reduce((e, n, r) => {\n    var s = t(n, r);\n    return s && (e[s[0]] = s[1]), e;\n  }, {});\n}\nfunction b(e, t) {\n  if (\"string\" == typeof t && o(e, t)) return e[t];\n  if (!t) return e;\n  if (\"string\" != typeof t) {\n    for (var n = [], r = 0, s = t.length; r < s; ++r) {\n      var i = b(e, t[r]);\n      n.push(i);\n    }\n    return n;\n  }\n  var a = t.indexOf(\".\");\n  if (-1 !== a) {\n    var u = e[t.substr(0, a)];\n    return null == u ? void 0 : b(u, t.substr(a + 1));\n  }\n}\nfunction _(e, t, r) {\n  if (e && void 0 !== t && (!(\"isFrozen\" in Object) || !Object.isFrozen(e))) if (\"string\" != typeof t && \"length\" in t) {\n    m(\"string\" != typeof r && \"length\" in r);\n    for (var s = 0, i = t.length; s < i; ++s) _(e, t[s], r[s]);\n  } else {\n    var a = t.indexOf(\".\");\n    if (-1 !== a) {\n      var u = t.substr(0, a),\n        l = t.substr(a + 1);\n      if (\"\" === l) void 0 === r ? n(e) && !isNaN(parseInt(u)) ? e.splice(u, 1) : delete e[u] : e[u] = r;else {\n        var c = e[u];\n        c && o(e, u) || (c = e[u] = {}), _(c, l, r);\n      }\n    } else void 0 === r ? n(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r;\n  }\n}\nfunction w(e) {\n  var t = {};\n  for (var n in e) o(e, n) && (t[n] = e[n]);\n  return t;\n}\nconst x = [].concat;\nfunction k(e) {\n  return x.apply([], e);\n}\nconst E = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(k([8, 16, 32, 64].map(e => [\"Int\", \"Uint\", \"Float\"].map(t => t + e + \"Array\")))).filter(t => e[t]),\n  P = E.map(t => e[t]);\ng(E, e => [e, !0]);\nlet K = null;\nfunction O(e) {\n  K = \"undefined\" != typeof WeakMap && new WeakMap();\n  const t = S(e);\n  return K = null, t;\n}\nfunction S(e) {\n  if (!e || \"object\" != typeof e) return e;\n  let t = K && K.get(e);\n  if (t) return t;\n  if (n(e)) {\n    t = [], K && K.set(e, t);\n    for (var r = 0, i = e.length; r < i; ++r) t.push(S(e[r]));\n  } else if (P.indexOf(e.constructor) >= 0) t = e;else {\n    const n = s(e);\n    for (var a in t = n === Object.prototype ? {} : Object.create(n), K && K.set(e, t), e) o(e, a) && (t[a] = S(e[a]));\n  }\n  return t;\n}\nconst {\n  toString: A\n} = {};\nfunction C(e) {\n  return A.call(e).slice(8, -1);\n}\nconst j = \"undefined\" != typeof Symbol ? Symbol.iterator : \"@@iterator\",\n  D = \"symbol\" == typeof j ? function (e) {\n    var t;\n    return null != e && (t = e[j]) && t.apply(e);\n  } : function () {\n    return null;\n  },\n  I = {};\nfunction B(e) {\n  var t, r, s, i;\n  if (1 === arguments.length) {\n    if (n(e)) return e.slice();\n    if (this === I && \"string\" == typeof e) return [e];\n    if (i = D(e)) {\n      for (r = []; !(s = i.next()).done;) r.push(s.value);\n      return r;\n    }\n    if (null == e) return [e];\n    if (\"number\" == typeof (t = e.length)) {\n      for (r = new Array(t); t--;) r[t] = e[t];\n      return r;\n    }\n    return [e];\n  }\n  for (t = arguments.length, r = new Array(t); t--;) r[t] = arguments[t];\n  return r;\n}\nconst T = \"undefined\" != typeof Symbol ? e => \"AsyncFunction\" === e[Symbol.toStringTag] : () => !1;\nvar R = \"undefined\" != typeof location && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction F(e, t) {\n  R = e, M = t;\n}\nvar M = () => !0;\nconst N = !new Error(\"\").stack;\nfunction q() {\n  if (N) try {\n    throw q.arguments, new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\nfunction $(e, t) {\n  var n = e.stack;\n  return n ? (t = t || 0, 0 === n.indexOf(e.name) && (t += (e.name + e.message).split(\"\\n\").length), n.split(\"\\n\").slice(t).filter(M).map(e => \"\\n\" + e).join(\"\")) : \"\";\n}\nvar U = [\"Unknown\", \"Constraint\", \"Data\", \"TransactionInactive\", \"ReadOnly\", \"Version\", \"NotFound\", \"InvalidState\", \"InvalidAccess\", \"Abort\", \"Timeout\", \"QuotaExceeded\", \"Syntax\", \"DataClone\"],\n  L = [\"Modify\", \"Bulk\", \"OpenFailed\", \"VersionChange\", \"Schema\", \"Upgrade\", \"InvalidTable\", \"MissingAPI\", \"NoSuchDatabase\", \"InvalidArgument\", \"SubTransaction\", \"Unsupported\", \"Internal\", \"DatabaseClosed\", \"PrematureCommit\", \"ForeignAwait\"].concat(U),\n  V = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n  };\nfunction W(e, t) {\n  this._e = q(), this.name = e, this.message = t;\n}\nfunction Y(e, t) {\n  return e + \". Errors: \" + Object.keys(t).map(e => t[e].toString()).filter((e, t, n) => n.indexOf(e) === t).join(\"\\n\");\n}\nfunction z(e, t, n, r) {\n  this._e = q(), this.failures = t, this.failedKeys = r, this.successCount = n, this.message = Y(e, t);\n}\nfunction G(e, t) {\n  this._e = q(), this.name = \"BulkError\", this.failures = Object.keys(t).map(e => t[e]), this.failuresByPos = t, this.message = Y(e, t);\n}\nc(W).from(Error).extend({\n  stack: {\n    get: function () {\n      return this._stack || (this._stack = this.name + \": \" + this.message + $(this._e, 2));\n    }\n  },\n  toString: function () {\n    return this.name + \": \" + this.message;\n  }\n}), c(z).from(W), c(G).from(W);\nvar H = L.reduce((e, t) => (e[t] = t + \"Error\", e), {});\nconst Q = W;\nvar X = L.reduce((e, t) => {\n  var n = t + \"Error\";\n  function r(e, r) {\n    this._e = q(), this.name = n, e ? \"string\" == typeof e ? (this.message = `${e}${r ? \"\\n \" + r : \"\"}`, this.inner = r || null) : \"object\" == typeof e && (this.message = `${e.name} ${e.message}`, this.inner = e) : (this.message = V[t] || n, this.inner = null);\n  }\n  return c(r).from(Q), e[t] = r, e;\n}, {});\nX.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;\nvar J = U.reduce((e, t) => (e[t + \"Error\"] = X[t], e), {});\nvar Z = L.reduce((e, t) => (-1 === [\"Syntax\", \"Type\", \"Range\"].indexOf(t) && (e[t + \"Error\"] = X[t]), e), {});\nfunction ee() {}\nfunction te(e) {\n  return e;\n}\nfunction ne(e, t) {\n  return null == e || e === te ? t : function (n) {\n    return t(e(n));\n  };\n}\nfunction re(e, t) {\n  return function () {\n    e.apply(this, arguments), t.apply(this, arguments);\n  };\n}\nfunction se(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n    void 0 !== n && (arguments[0] = n);\n    var r = this.onsuccess,\n      s = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var i = t.apply(this, arguments);\n    return r && (this.onsuccess = this.onsuccess ? re(r, this.onsuccess) : r), s && (this.onerror = this.onerror ? re(s, this.onerror) : s), void 0 !== i ? i : n;\n  };\n}\nfunction ie(e, t) {\n  return e === ee ? t : function () {\n    e.apply(this, arguments);\n    var n = this.onsuccess,\n      r = this.onerror;\n    this.onsuccess = this.onerror = null, t.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? re(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? re(r, this.onerror) : r);\n  };\n}\nfunction oe(e, t) {\n  return e === ee ? t : function (n) {\n    var s = e.apply(this, arguments);\n    r(n, s);\n    var i = this.onsuccess,\n      o = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var a = t.apply(this, arguments);\n    return i && (this.onsuccess = this.onsuccess ? re(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? re(o, this.onerror) : o), void 0 === s ? void 0 === a ? void 0 : a : r(s, a);\n  };\n}\nfunction ae(e, t) {\n  return e === ee ? t : function () {\n    return !1 !== t.apply(this, arguments) && e.apply(this, arguments);\n  };\n}\nfunction ue(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n    if (n && \"function\" == typeof n.then) {\n      for (var r = this, s = arguments.length, i = new Array(s); s--;) i[s] = arguments[s];\n      return n.then(function () {\n        return t.apply(r, i);\n      });\n    }\n    return t.apply(this, arguments);\n  };\n}\nZ.ModifyError = z, Z.DexieError = W, Z.BulkError = G;\nvar le = {};\nconst ce = 100,\n  [he, de, fe] = \"undefined\" == typeof Promise ? [] : (() => {\n    let e = Promise.resolve();\n    if (\"undefined\" == typeof crypto || !crypto.subtle) return [e, s(e), e];\n    const t = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n    return [t, s(t), e];\n  })(),\n  pe = de && de.then,\n  ye = he && he.constructor,\n  me = !!fe;\nvar ve = !1,\n  ge = fe ? () => {\n    fe.then($e);\n  } : e.setImmediate ? setImmediate.bind(null, $e) : e.MutationObserver ? () => {\n    var e = document.createElement(\"div\");\n    new MutationObserver(() => {\n      $e(), e = null;\n    }).observe(e, {\n      attributes: !0\n    }), e.setAttribute(\"i\", \"1\");\n  } : () => {\n    setTimeout($e, 0);\n  },\n  be = function (e, t) {\n    Se.push([e, t]), we && (ge(), we = !1);\n  },\n  _e = !0,\n  we = !0,\n  xe = [],\n  ke = [],\n  Ee = null,\n  Pe = te,\n  Ke = {\n    id: \"global\",\n    global: !0,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: dt,\n    pgp: !1,\n    env: {},\n    finalize: function () {\n      this.unhandleds.forEach(e => {\n        try {\n          dt(e[0], e[1]);\n        } catch (e) {}\n      });\n    }\n  },\n  Oe = Ke,\n  Se = [],\n  Ae = 0,\n  Ce = [];\nfunction je(e) {\n  if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\");\n  this._listeners = [], this.onuncatched = ee, this._lib = !1;\n  var t = this._PSD = Oe;\n  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), \"function\" != typeof e) {\n    if (e !== le) throw new TypeError(\"Not a function\");\n    return this._state = arguments[1], this._value = arguments[2], void (!1 === this._state && Te(this, this._value));\n  }\n  this._state = null, this._value = null, ++t.ref, Be(this, e);\n}\nconst De = {\n  get: function () {\n    var e = Oe,\n      t = Xe;\n    function n(n, r) {\n      var s = !e.global && (e !== Oe || t !== Xe);\n      const i = s && !tt();\n      var o = new je((t, o) => {\n        Fe(this, new Ie(lt(n, e, s, i), lt(r, e, s, i), t, o, e));\n      });\n      return R && qe(o, this), o;\n    }\n    return n.prototype = le, n;\n  },\n  set: function (e) {\n    l(this, \"then\", e && e.prototype === le ? De : {\n      get: function () {\n        return e;\n      },\n      set: De.set\n    });\n  }\n};\nfunction Ie(e, t, n, r, s) {\n  this.onFulfilled = \"function\" == typeof e ? e : null, this.onRejected = \"function\" == typeof t ? t : null, this.resolve = n, this.reject = r, this.psd = s;\n}\nfunction Be(e, t) {\n  try {\n    t(t => {\n      if (null === e._state) {\n        if (t === e) throw new TypeError(\"A promise cannot be resolved with itself.\");\n        var n = e._lib && Ue();\n        t && \"function\" == typeof t.then ? Be(e, (e, n) => {\n          t instanceof je ? t._then(e, n) : t.then(e, n);\n        }) : (e._state = !0, e._value = t, Re(e)), n && Le();\n      }\n    }, Te.bind(null, e));\n  } catch (t) {\n    Te(e, t);\n  }\n}\nfunction Te(e, t) {\n  if (ke.push(t), null === e._state) {\n    var n = e._lib && Ue();\n    t = Pe(t), e._state = !1, e._value = t, R && null !== t && \"object\" == typeof t && !t._promise && function (e, t, n) {\n      try {\n        e.apply(null, n);\n      } catch (e) {\n        t && t(e);\n      }\n    }(() => {\n      var n = d(t, \"stack\");\n      t._promise = e, l(t, \"stack\", {\n        get: () => ve ? n && (n.get ? n.get.apply(t) : n.value) : e.stack\n      });\n    }), function (e) {\n      xe.some(t => t._value === e._value) || xe.push(e);\n    }(e), Re(e), n && Le();\n  }\n}\nfunction Re(e) {\n  var t = e._listeners;\n  e._listeners = [];\n  for (var n = 0, r = t.length; n < r; ++n) Fe(e, t[n]);\n  var s = e._PSD;\n  --s.ref || s.finalize(), 0 === Ae && (++Ae, be(() => {\n    0 == --Ae && Ve();\n  }, []));\n}\nfunction Fe(e, t) {\n  if (null !== e._state) {\n    var n = e._state ? t.onFulfilled : t.onRejected;\n    if (null === n) return (e._state ? t.resolve : t.reject)(e._value);\n    ++t.psd.ref, ++Ae, be(Me, [n, e, t]);\n  } else e._listeners.push(t);\n}\nfunction Me(e, t, n) {\n  try {\n    Ee = t;\n    var r,\n      s = t._value;\n    t._state ? r = e(s) : (ke.length && (ke = []), r = e(s), -1 === ke.indexOf(s) && function (e) {\n      var t = xe.length;\n      for (; t;) if (xe[--t]._value === e._value) return void xe.splice(t, 1);\n    }(t)), n.resolve(r);\n  } catch (e) {\n    n.reject(e);\n  } finally {\n    Ee = null, 0 == --Ae && Ve(), --n.psd.ref || n.psd.finalize();\n  }\n}\nfunction Ne(e, t, n) {\n  if (t.length === n) return t;\n  var r = \"\";\n  if (!1 === e._state) {\n    var s,\n      i,\n      o = e._value;\n    null != o ? (s = o.name || \"Error\", i = o.message || o, r = $(o, 0)) : (s = o, i = \"\"), t.push(s + (i ? \": \" + i : \"\") + r);\n  }\n  return R && ((r = $(e._stackHolder, 2)) && -1 === t.indexOf(r) && t.push(r), e._prev && Ne(e._prev, t, n)), t;\n}\nfunction qe(e, t) {\n  var n = t ? t._numPrev + 1 : 0;\n  n < 100 && (e._prev = t, e._numPrev = n);\n}\nfunction $e() {\n  Ue() && Le();\n}\nfunction Ue() {\n  var e = _e;\n  return _e = !1, we = !1, e;\n}\nfunction Le() {\n  var e, t, n;\n  do {\n    for (; Se.length > 0;) for (e = Se, Se = [], n = e.length, t = 0; t < n; ++t) {\n      var r = e[t];\n      r[0].apply(null, r[1]);\n    }\n  } while (Se.length > 0);\n  _e = !0, we = !0;\n}\nfunction Ve() {\n  var e = xe;\n  xe = [], e.forEach(e => {\n    e._PSD.onunhandled.call(null, e._value, e);\n  });\n  for (var t = Ce.slice(0), n = t.length; n;) t[--n]();\n}\nfunction We(e) {\n  return new je(le, !1, e);\n}\nfunction Ye(e, t) {\n  var n = Oe;\n  return function () {\n    var r = Ue(),\n      s = Oe;\n    try {\n      return it(n, !0), e.apply(this, arguments);\n    } catch (e) {\n      t && t(e);\n    } finally {\n      it(s, !1), r && Le();\n    }\n  };\n}\na(je.prototype, {\n  then: De,\n  _then: function (e, t) {\n    Fe(this, new Ie(null, null, e, t, Oe));\n  },\n  catch: function (e) {\n    if (1 === arguments.length) return this.then(null, e);\n    var t = arguments[0],\n      n = arguments[1];\n    return \"function\" == typeof t ? this.then(null, e => e instanceof t ? n(e) : We(e)) : this.then(null, e => e && e.name === t ? n(e) : We(e));\n  },\n  finally: function (e) {\n    return this.then(t => (e(), t), t => (e(), We(t)));\n  },\n  stack: {\n    get: function () {\n      if (this._stack) return this._stack;\n      try {\n        ve = !0;\n        var e = Ne(this, [], 20).join(\"\\nFrom previous: \");\n        return null !== this._state && (this._stack = e), e;\n      } finally {\n        ve = !1;\n      }\n    }\n  },\n  timeout: function (e, t) {\n    return e < 1 / 0 ? new je((n, r) => {\n      var s = setTimeout(() => r(new X.Timeout(t)), e);\n      this.then(n, r).finally(clearTimeout.bind(null, s));\n    }) : this;\n  }\n}), \"undefined\" != typeof Symbol && Symbol.toStringTag && l(je.prototype, Symbol.toStringTag, \"Dexie.Promise\"), Ke.env = ot(), a(je, {\n  all: function () {\n    var e = B.apply(null, arguments).map(nt);\n    return new je(function (t, n) {\n      0 === e.length && t([]);\n      var r = e.length;\n      e.forEach((s, i) => je.resolve(s).then(n => {\n        e[i] = n, --r || t(e);\n      }, n));\n    });\n  },\n  resolve: e => {\n    if (e instanceof je) return e;\n    if (e && \"function\" == typeof e.then) return new je((t, n) => {\n      e.then(t, n);\n    });\n    var t = new je(le, !0, e);\n    return qe(t, Ee), t;\n  },\n  reject: We,\n  race: function () {\n    var e = B.apply(null, arguments).map(nt);\n    return new je((t, n) => {\n      e.map(e => je.resolve(e).then(t, n));\n    });\n  },\n  PSD: {\n    get: () => Oe,\n    set: e => Oe = e\n  },\n  totalEchoes: {\n    get: () => Xe\n  },\n  newPSD: Ze,\n  usePSD: at,\n  scheduler: {\n    get: () => be,\n    set: e => {\n      be = e;\n    }\n  },\n  rejectionMapper: {\n    get: () => Pe,\n    set: e => {\n      Pe = e;\n    }\n  },\n  follow: (e, t) => new je((n, r) => Ze((t, n) => {\n    var r = Oe;\n    r.unhandleds = [], r.onunhandled = n, r.finalize = re(function () {\n      !function (e) {\n        function t() {\n          e(), Ce.splice(Ce.indexOf(t), 1);\n        }\n        Ce.push(t), ++Ae, be(() => {\n          0 == --Ae && Ve();\n        }, []);\n      }(() => {\n        0 === this.unhandleds.length ? t() : n(this.unhandleds[0]);\n      });\n    }, r.finalize), e();\n  }, t, n, r))\n}), ye && (ye.allSettled && l(je, \"allSettled\", function () {\n  const e = B.apply(null, arguments).map(nt);\n  return new je(t => {\n    0 === e.length && t([]);\n    let n = e.length;\n    const r = new Array(n);\n    e.forEach((e, s) => je.resolve(e).then(e => r[s] = {\n      status: \"fulfilled\",\n      value: e\n    }, e => r[s] = {\n      status: \"rejected\",\n      reason: e\n    }).then(() => --n || t(r)));\n  });\n}), ye.any && \"undefined\" != typeof AggregateError && l(je, \"any\", function () {\n  const e = B.apply(null, arguments).map(nt);\n  return new je((t, n) => {\n    0 === e.length && n(new AggregateError([]));\n    let r = e.length;\n    const s = new Array(r);\n    e.forEach((e, i) => je.resolve(e).then(e => t(e), e => {\n      s[i] = e, --r || n(new AggregateError(s));\n    }));\n  });\n}));\nconst ze = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar Ge = 0,\n  He = [],\n  Qe = 0,\n  Xe = 0,\n  Je = 0;\nfunction Ze(e, t, n, s) {\n  var i = Oe,\n    o = Object.create(i);\n  o.parent = i, o.ref = 0, o.global = !1, o.id = ++Je;\n  var a = Ke.env;\n  o.env = me ? {\n    Promise: je,\n    PromiseProp: {\n      value: je,\n      configurable: !0,\n      writable: !0\n    },\n    all: je.all,\n    race: je.race,\n    allSettled: je.allSettled,\n    any: je.any,\n    resolve: je.resolve,\n    reject: je.reject,\n    nthen: ct(a.nthen, o),\n    gthen: ct(a.gthen, o)\n  } : {}, t && r(o, t), ++i.ref, o.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n  var u = at(o, e, n, s);\n  return 0 === o.ref && o.finalize(), u;\n}\nfunction et() {\n  return ze.id || (ze.id = ++Ge), ++ze.awaits, ze.echoes += ce, ze.id;\n}\nfunction tt() {\n  return !!ze.awaits && (0 == --ze.awaits && (ze.id = 0), ze.echoes = ze.awaits * ce, !0);\n}\nfunction nt(e) {\n  return ze.echoes && e && e.constructor === ye ? (et(), e.then(e => (tt(), e), e => (tt(), ft(e)))) : e;\n}\nfunction rt(e) {\n  ++Xe, ze.echoes && 0 != --ze.echoes || (ze.echoes = ze.id = 0), He.push(Oe), it(e, !0);\n}\nfunction st() {\n  var e = He[He.length - 1];\n  He.pop(), it(e, !1);\n}\nfunction it(t, n) {\n  var r = Oe;\n  if ((n ? !ze.echoes || Qe++ && t === Oe : !Qe || --Qe && t === Oe) || ut(n ? rt.bind(null, t) : st), t !== Oe && (Oe = t, r === Ke && (Ke.env = ot()), me)) {\n    var s = Ke.env.Promise,\n      i = t.env;\n    de.then = i.nthen, s.prototype.then = i.gthen, (r.global || t.global) && (Object.defineProperty(e, \"Promise\", i.PromiseProp), s.all = i.all, s.race = i.race, s.resolve = i.resolve, s.reject = i.reject, i.allSettled && (s.allSettled = i.allSettled), i.any && (s.any = i.any));\n  }\n}\nfunction ot() {\n  var t = e.Promise;\n  return me ? {\n    Promise: t,\n    PromiseProp: Object.getOwnPropertyDescriptor(e, \"Promise\"),\n    all: t.all,\n    race: t.race,\n    allSettled: t.allSettled,\n    any: t.any,\n    resolve: t.resolve,\n    reject: t.reject,\n    nthen: de.then,\n    gthen: t.prototype.then\n  } : {};\n}\nfunction at(e, t, n, r, s) {\n  var i = Oe;\n  try {\n    return it(e, !0), t(n, r, s);\n  } finally {\n    it(i, !1);\n  }\n}\nfunction ut(e) {\n  pe.call(he, e);\n}\nfunction lt(e, t, n, r) {\n  return \"function\" != typeof e ? e : function () {\n    var s = Oe;\n    n && et(), it(t, !0);\n    try {\n      return e.apply(this, arguments);\n    } finally {\n      it(s, !1), r && ut(tt);\n    }\n  };\n}\nfunction ct(e, t) {\n  return function (n, r) {\n    return e.call(this, lt(n, t), lt(r, t));\n  };\n}\n-1 === (\"\" + pe).indexOf(\"[native code]\") && (et = tt = ee);\nconst ht = \"unhandledrejection\";\nfunction dt(t, n) {\n  var s;\n  try {\n    s = n.onuncatched(t);\n  } catch (e) {}\n  if (!1 !== s) try {\n    var i,\n      o = {\n        promise: n,\n        reason: t\n      };\n    if (e.document && document.createEvent ? ((i = document.createEvent(\"Event\")).initEvent(ht, !0, !0), r(i, o)) : e.CustomEvent && r(i = new CustomEvent(ht, {\n      detail: o\n    }), o), i && e.dispatchEvent && (dispatchEvent(i), !e.PromiseRejectionEvent && e.onunhandledrejection)) try {\n      e.onunhandledrejection(i);\n    } catch (e) {}\n    R && i && !i.defaultPrevented && console.warn(`Unhandled rejection: ${t.stack || t}`);\n  } catch (e) {}\n}\nvar ft = je.reject;\nfunction pt(e, t, n, r) {\n  if (e.idbdb && (e._state.openComplete || Oe.letThrough || e._vip)) {\n    var s = e._createTransaction(t, n, e._dbSchema);\n    try {\n      s.create(), e._state.PR1398_maxLoop = 3;\n    } catch (s) {\n      return s.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(() => pt(e, t, n, r))) : ft(s);\n    }\n    return s._promise(t, (e, t) => Ze(() => (Oe.trans = s, r(e, t, s)))).then(e => s._completion.then(() => e));\n  }\n  if (e._state.openComplete) return ft(new X.DatabaseClosed(e._state.dbOpenError));\n  if (!e._state.isBeingOpened) {\n    if (!e._options.autoOpen) return ft(new X.DatabaseClosed());\n    e.open().catch(ee);\n  }\n  return e._state.dbReadyPromise.then(() => pt(e, t, n, r));\n}\nconst yt = \"3.2.7\",\n  mt = String.fromCharCode(65535),\n  vt = -1 / 0,\n  gt = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\",\n  bt = \"String expected.\",\n  _t = [],\n  wt = \"undefined\" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent),\n  xt = wt,\n  kt = wt,\n  Et = e => !/(dexie\\.js|dexie\\.min\\.js)/.test(e),\n  Pt = \"__dbnames\",\n  Kt = \"readonly\",\n  Ot = \"readwrite\";\nfunction St(e, t) {\n  return e ? t ? function () {\n    return e.apply(this, arguments) && t.apply(this, arguments);\n  } : e : t;\n}\nconst At = {\n  type: 3,\n  lower: -1 / 0,\n  lowerOpen: !1,\n  upper: [[]],\n  upperOpen: !1\n};\nfunction Ct(e) {\n  return \"string\" != typeof e || /\\./.test(e) ? e => e : t => (void 0 === t[e] && e in t && delete (t = O(t))[e], t);\n}\nclass jt {\n  _trans(e, t, n) {\n    const r = this._tx || Oe.trans,\n      s = this.name;\n    function i(e, n, r) {\n      if (!r.schema[s]) throw new X.NotFound(\"Table \" + s + \" not part of transaction\");\n      return t(r.idbtrans, r);\n    }\n    const o = Ue();\n    try {\n      return r && r.db === this.db ? r === Oe.trans ? r._promise(e, i, n) : Ze(() => r._promise(e, i, n), {\n        trans: r,\n        transless: Oe.transless || Oe\n      }) : pt(this.db, e, [this.name], i);\n    } finally {\n      o && Le();\n    }\n  }\n  get(e, t) {\n    return e && e.constructor === Object ? this.where(e).first(t) : this._trans(\"readonly\", t => this.core.get({\n      trans: t,\n      key: e\n    }).then(e => this.hook.reading.fire(e))).then(t);\n  }\n  where(e) {\n    if (\"string\" == typeof e) return new this.db.WhereClause(this, e);\n    if (n(e)) return new this.db.WhereClause(this, `[${e.join(\"+\")}]`);\n    const r = t(e);\n    if (1 === r.length) return this.where(r[0]).equals(e[r[0]]);\n    const s = this.schema.indexes.concat(this.schema.primKey).filter(e => {\n      if (e.compound && r.every(t => e.keyPath.indexOf(t) >= 0)) {\n        for (let t = 0; t < r.length; ++t) if (-1 === r.indexOf(e.keyPath[t])) return !1;\n        return !0;\n      }\n      return !1;\n    }).sort((e, t) => e.keyPath.length - t.keyPath.length)[0];\n    if (s && this.db._maxKey !== mt) {\n      const t = s.keyPath.slice(0, r.length);\n      return this.where(t).equals(t.map(t => e[t]));\n    }\n    !s && R && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${r.join(\"+\")}]`);\n    const {\n        idxByName: i\n      } = this.schema,\n      o = this.db._deps.indexedDB;\n    function a(e, t) {\n      try {\n        return 0 === o.cmp(e, t);\n      } catch (e) {\n        return !1;\n      }\n    }\n    const [u, l] = r.reduce(([t, r], s) => {\n      const o = i[s],\n        u = e[s];\n      return [t || o, t || !o ? St(r, o && o.multi ? e => {\n        const t = b(e, s);\n        return n(t) && t.some(e => a(u, e));\n      } : e => a(u, b(e, s))) : r];\n    }, [null, null]);\n    return u ? this.where(u.name).equals(e[u.keyPath]).filter(l) : s ? this.filter(l) : this.where(r).equals(\"\");\n  }\n  filter(e) {\n    return this.toCollection().and(e);\n  }\n  count(e) {\n    return this.toCollection().count(e);\n  }\n  offset(e) {\n    return this.toCollection().offset(e);\n  }\n  limit(e) {\n    return this.toCollection().limit(e);\n  }\n  each(e) {\n    return this.toCollection().each(e);\n  }\n  toArray(e) {\n    return this.toCollection().toArray(e);\n  }\n  toCollection() {\n    return new this.db.Collection(new this.db.WhereClause(this));\n  }\n  orderBy(e) {\n    return new this.db.Collection(new this.db.WhereClause(this, n(e) ? `[${e.join(\"+\")}]` : e));\n  }\n  reverse() {\n    return this.toCollection().reverse();\n  }\n  mapToClass(e) {\n    this.schema.mappedClass = e;\n    const t = t => {\n      if (!t) return t;\n      const n = Object.create(e.prototype);\n      for (var r in t) if (o(t, r)) try {\n        n[r] = t[r];\n      } catch (e) {}\n      return n;\n    };\n    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = t, this.hook(\"reading\", t), e;\n  }\n  defineClass() {\n    return this.mapToClass(function (e) {\n      r(this, e);\n    });\n  }\n  add(e, t) {\n    const {\n      auto: n,\n      keyPath: r\n    } = this.schema.primKey;\n    let s = e;\n    return r && n && (s = Ct(r)(e)), this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"add\",\n      keys: null != t ? [t] : null,\n      values: [s]\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : e.lastResult).then(t => {\n      if (r) try {\n        _(e, r, t);\n      } catch (e) {}\n      return t;\n    });\n  }\n  update(e, r) {\n    if (\"object\" != typeof e || n(e)) return this.where(\":id\").equals(e).modify(r);\n    {\n      const n = b(e, this.schema.primKey.keyPath);\n      if (void 0 === n) return ft(new X.InvalidArgument(\"Given object does not contain its primary key\"));\n      try {\n        \"function\" != typeof r ? t(r).forEach(t => {\n          _(e, t, r[t]);\n        }) : r(e, {\n          value: e,\n          primKey: n\n        });\n      } catch (e) {}\n      return this.where(\":id\").equals(n).modify(r);\n    }\n  }\n  put(e, t) {\n    const {\n      auto: n,\n      keyPath: r\n    } = this.schema.primKey;\n    let s = e;\n    return r && n && (s = Ct(r)(e)), this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"put\",\n      values: [s],\n      keys: null != t ? [t] : null\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : e.lastResult).then(t => {\n      if (r) try {\n        _(e, r, t);\n      } catch (e) {}\n      return t;\n    });\n  }\n  delete(e) {\n    return this._trans(\"readwrite\", t => this.core.mutate({\n      trans: t,\n      type: \"delete\",\n      keys: [e]\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : void 0);\n  }\n  clear() {\n    return this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"deleteRange\",\n      range: At\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : void 0);\n  }\n  bulkGet(e) {\n    return this._trans(\"readonly\", t => this.core.getMany({\n      keys: e,\n      trans: t\n    }).then(e => e.map(e => this.hook.reading.fire(e))));\n  }\n  bulkAdd(e, t, n) {\n    const r = Array.isArray(t) ? t : void 0,\n      s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n    return this._trans(\"readwrite\", t => {\n      const {\n        auto: n,\n        keyPath: i\n      } = this.schema.primKey;\n      if (i && r) throw new X.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n      if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const o = e.length;\n      let a = i && n ? e.map(Ct(i)) : e;\n      return this.core.mutate({\n        trans: t,\n        type: \"add\",\n        keys: r,\n        values: a,\n        wantResults: s\n      }).then(({\n        numFailures: e,\n        results: t,\n        lastResult: n,\n        failures: r\n      }) => {\n        if (0 === e) return s ? t : n;\n        throw new G(`${this.name}.bulkAdd(): ${e} of ${o} operations failed`, r);\n      });\n    });\n  }\n  bulkPut(e, t, n) {\n    const r = Array.isArray(t) ? t : void 0,\n      s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n    return this._trans(\"readwrite\", t => {\n      const {\n        auto: n,\n        keyPath: i\n      } = this.schema.primKey;\n      if (i && r) throw new X.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n      if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const o = e.length;\n      let a = i && n ? e.map(Ct(i)) : e;\n      return this.core.mutate({\n        trans: t,\n        type: \"put\",\n        keys: r,\n        values: a,\n        wantResults: s\n      }).then(({\n        numFailures: e,\n        results: t,\n        lastResult: n,\n        failures: r\n      }) => {\n        if (0 === e) return s ? t : n;\n        throw new G(`${this.name}.bulkPut(): ${e} of ${o} operations failed`, r);\n      });\n    });\n  }\n  bulkDelete(e) {\n    const t = e.length;\n    return this._trans(\"readwrite\", t => this.core.mutate({\n      trans: t,\n      type: \"delete\",\n      keys: e\n    })).then(({\n      numFailures: e,\n      lastResult: n,\n      failures: r\n    }) => {\n      if (0 === e) return n;\n      throw new G(`${this.name}.bulkDelete(): ${e} of ${t} operations failed`, r);\n    });\n  }\n}\nfunction Dt(e) {\n  var r = {},\n    s = function (t, n) {\n      if (n) {\n        for (var s = arguments.length, i = new Array(s - 1); --s;) i[s - 1] = arguments[s];\n        return r[t].subscribe.apply(null, i), e;\n      }\n      if (\"string\" == typeof t) return r[t];\n    };\n  s.addEventType = a;\n  for (var i = 1, o = arguments.length; i < o; ++i) a(arguments[i]);\n  return s;\n  function a(e, i, o) {\n    if (\"object\" != typeof e) {\n      var u;\n      i || (i = ae), o || (o = ee);\n      var l = {\n        subscribers: [],\n        fire: o,\n        subscribe: function (e) {\n          -1 === l.subscribers.indexOf(e) && (l.subscribers.push(e), l.fire = i(l.fire, e));\n        },\n        unsubscribe: function (e) {\n          l.subscribers = l.subscribers.filter(function (t) {\n            return t !== e;\n          }), l.fire = l.subscribers.reduce(i, o);\n        }\n      };\n      return r[e] = s[e] = l, l;\n    }\n    t(u = e).forEach(function (e) {\n      var t = u[e];\n      if (n(t)) a(e, u[e][0], u[e][1]);else {\n        if (\"asap\" !== t) throw new X.InvalidArgument(\"Invalid event config\");\n        var r = a(e, te, function () {\n          for (var e = arguments.length, t = new Array(e); e--;) t[e] = arguments[e];\n          r.subscribers.forEach(function (e) {\n            v(function () {\n              e.apply(null, t);\n            });\n          });\n        });\n      }\n    });\n  }\n}\nfunction It(e, t) {\n  return c(t).from({\n    prototype: e\n  }), t;\n}\nfunction Bt(e, t) {\n  return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);\n}\nfunction Tt(e, t) {\n  e.filter = St(e.filter, t);\n}\nfunction Rt(e, t, n) {\n  var r = e.replayFilter;\n  e.replayFilter = r ? () => St(r(), t()) : t, e.justLimit = n && !r;\n}\nfunction Ft(e, t) {\n  if (e.isPrimKey) return t.primaryKey;\n  const n = t.getIndexByKeyPath(e.index);\n  if (!n) throw new X.Schema(\"KeyPath \" + e.index + \" on object store \" + t.name + \" is not indexed\");\n  return n;\n}\nfunction Mt(e, t, n) {\n  const r = Ft(e, t.schema);\n  return t.openCursor({\n    trans: n,\n    values: !e.keysOnly,\n    reverse: \"prev\" === e.dir,\n    unique: !!e.unique,\n    query: {\n      index: r,\n      range: e.range\n    }\n  });\n}\nfunction Nt(e, t, n, r) {\n  const s = e.replayFilter ? St(e.filter, e.replayFilter()) : e.filter;\n  if (e.or) {\n    const i = {},\n      a = (e, n, r) => {\n        if (!s || s(n, r, e => n.stop(e), e => n.fail(e))) {\n          var a = n.primaryKey,\n            u = \"\" + a;\n          \"[object ArrayBuffer]\" === u && (u = \"\" + new Uint8Array(a)), o(i, u) || (i[u] = !0, t(e, n, r));\n        }\n      };\n    return Promise.all([e.or._iterate(a, n), qt(Mt(e, r, n), e.algorithm, a, !e.keysOnly && e.valueMapper)]);\n  }\n  return qt(Mt(e, r, n), St(e.algorithm, s), t, !e.keysOnly && e.valueMapper);\n}\nfunction qt(e, t, n, r) {\n  var s = Ye(r ? (e, t, s) => n(r(e), t, s) : n);\n  return e.then(e => {\n    if (e) return e.start(() => {\n      var n = () => e.continue();\n      t && !t(e, e => n = e, t => {\n        e.stop(t), n = ee;\n      }, t => {\n        e.fail(t), n = ee;\n      }) || s(e.value, e, e => n = e), n();\n    });\n  });\n}\nfunction $t(e, t) {\n  try {\n    const n = Ut(e),\n      r = Ut(t);\n    if (n !== r) return \"Array\" === n ? 1 : \"Array\" === r ? -1 : \"binary\" === n ? 1 : \"binary\" === r ? -1 : \"string\" === n ? 1 : \"string\" === r ? -1 : \"Date\" === n ? 1 : \"Date\" !== r ? NaN : -1;\n    switch (n) {\n      case \"number\":\n      case \"Date\":\n      case \"string\":\n        return e > t ? 1 : e < t ? -1 : 0;\n      case \"binary\":\n        return function (e, t) {\n          const n = e.length,\n            r = t.length,\n            s = n < r ? n : r;\n          for (let n = 0; n < s; ++n) if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(Lt(e), Lt(t));\n      case \"Array\":\n        return function (e, t) {\n          const n = e.length,\n            r = t.length,\n            s = n < r ? n : r;\n          for (let n = 0; n < s; ++n) {\n            const r = $t(e[n], t[n]);\n            if (0 !== r) return r;\n          }\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(e, t);\n    }\n  } catch (e) {}\n  return NaN;\n}\nfunction Ut(e) {\n  const t = typeof e;\n  if (\"object\" !== t) return t;\n  if (ArrayBuffer.isView(e)) return \"binary\";\n  const n = C(e);\n  return \"ArrayBuffer\" === n ? \"binary\" : n;\n}\nfunction Lt(e) {\n  return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);\n}\nclass Vt {\n  _read(e, t) {\n    var n = this._ctx;\n    return n.error ? n.table._trans(null, ft.bind(null, n.error)) : n.table._trans(\"readonly\", e).then(t);\n  }\n  _write(e) {\n    var t = this._ctx;\n    return t.error ? t.table._trans(null, ft.bind(null, t.error)) : t.table._trans(\"readwrite\", e, \"locked\");\n  }\n  _addAlgorithm(e) {\n    var t = this._ctx;\n    t.algorithm = St(t.algorithm, e);\n  }\n  _iterate(e, t) {\n    return Nt(this._ctx, e, t, this._ctx.table.core);\n  }\n  clone(e) {\n    var t = Object.create(this.constructor.prototype),\n      n = Object.create(this._ctx);\n    return e && r(n, e), t._ctx = n, t;\n  }\n  raw() {\n    return this._ctx.valueMapper = null, this;\n  }\n  each(e) {\n    var t = this._ctx;\n    return this._read(n => Nt(t, e, n, t.table.core));\n  }\n  count(e) {\n    return this._read(e => {\n      const t = this._ctx,\n        n = t.table.core;\n      if (Bt(t, !0)) return n.count({\n        trans: e,\n        query: {\n          index: Ft(t, n.schema),\n          range: t.range\n        }\n      }).then(e => Math.min(e, t.limit));\n      var r = 0;\n      return Nt(t, () => (++r, !1), e, n).then(() => r);\n    }).then(e);\n  }\n  sortBy(e, t) {\n    const n = e.split(\".\").reverse(),\n      r = n[0],\n      s = n.length - 1;\n    function i(e, t) {\n      return t ? i(e[n[t]], t - 1) : e[r];\n    }\n    var o = \"next\" === this._ctx.dir ? 1 : -1;\n    function a(e, t) {\n      var n = i(e, s),\n        r = i(t, s);\n      return n < r ? -o : n > r ? o : 0;\n    }\n    return this.toArray(function (e) {\n      return e.sort(a);\n    }).then(t);\n  }\n  toArray(e) {\n    return this._read(e => {\n      var t = this._ctx;\n      if (\"next\" === t.dir && Bt(t, !0) && t.limit > 0) {\n        const {\n            valueMapper: n\n          } = t,\n          r = Ft(t, t.table.core.schema);\n        return t.table.core.query({\n          trans: e,\n          limit: t.limit,\n          values: !0,\n          query: {\n            index: r,\n            range: t.range\n          }\n        }).then(({\n          result: e\n        }) => n ? e.map(n) : e);\n      }\n      {\n        const n = [];\n        return Nt(t, e => n.push(e), e, t.table.core).then(() => n);\n      }\n    }, e);\n  }\n  offset(e) {\n    var t = this._ctx;\n    return e <= 0 || (t.offset += e, Bt(t) ? Rt(t, () => {\n      var t = e;\n      return (e, n) => 0 === t || (1 === t ? (--t, !1) : (n(() => {\n        e.advance(t), t = 0;\n      }), !1));\n    }) : Rt(t, () => {\n      var t = e;\n      return () => --t < 0;\n    })), this;\n  }\n  limit(e) {\n    return this._ctx.limit = Math.min(this._ctx.limit, e), Rt(this._ctx, () => {\n      var t = e;\n      return function (e, n, r) {\n        return --t <= 0 && n(r), t >= 0;\n      };\n    }, !0), this;\n  }\n  until(e, t) {\n    return Tt(this._ctx, function (n, r, s) {\n      return !e(n.value) || (r(s), t);\n    }), this;\n  }\n  first(e) {\n    return this.limit(1).toArray(function (e) {\n      return e[0];\n    }).then(e);\n  }\n  last(e) {\n    return this.reverse().first(e);\n  }\n  filter(e) {\n    var t, n;\n    return Tt(this._ctx, function (t) {\n      return e(t.value);\n    }), t = this._ctx, n = e, t.isMatch = St(t.isMatch, n), this;\n  }\n  and(e) {\n    return this.filter(e);\n  }\n  or(e) {\n    return new this.db.WhereClause(this._ctx.table, e, this);\n  }\n  reverse() {\n    return this._ctx.dir = \"prev\" === this._ctx.dir ? \"next\" : \"prev\", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;\n  }\n  desc() {\n    return this.reverse();\n  }\n  eachKey(e) {\n    var t = this._ctx;\n    return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n      e(n.key, n);\n    });\n  }\n  eachUniqueKey(e) {\n    return this._ctx.unique = \"unique\", this.eachKey(e);\n  }\n  eachPrimaryKey(e) {\n    var t = this._ctx;\n    return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n      e(n.primaryKey, n);\n    });\n  }\n  keys(e) {\n    var t = this._ctx;\n    t.keysOnly = !t.isMatch;\n    var n = [];\n    return this.each(function (e, t) {\n      n.push(t.key);\n    }).then(function () {\n      return n;\n    }).then(e);\n  }\n  primaryKeys(e) {\n    var t = this._ctx;\n    if (\"next\" === t.dir && Bt(t, !0) && t.limit > 0) return this._read(e => {\n      var n = Ft(t, t.table.core.schema);\n      return t.table.core.query({\n        trans: e,\n        values: !1,\n        limit: t.limit,\n        query: {\n          index: n,\n          range: t.range\n        }\n      });\n    }).then(({\n      result: e\n    }) => e).then(e);\n    t.keysOnly = !t.isMatch;\n    var n = [];\n    return this.each(function (e, t) {\n      n.push(t.primaryKey);\n    }).then(function () {\n      return n;\n    }).then(e);\n  }\n  uniqueKeys(e) {\n    return this._ctx.unique = \"unique\", this.keys(e);\n  }\n  firstKey(e) {\n    return this.limit(1).keys(function (e) {\n      return e[0];\n    }).then(e);\n  }\n  lastKey(e) {\n    return this.reverse().firstKey(e);\n  }\n  distinct() {\n    var e = this._ctx,\n      t = e.index && e.table.schema.idxByName[e.index];\n    if (!t || !t.multi) return this;\n    var n = {};\n    return Tt(this._ctx, function (e) {\n      var t = e.primaryKey.toString(),\n        r = o(n, t);\n      return n[t] = !0, !r;\n    }), this;\n  }\n  modify(e) {\n    var n = this._ctx;\n    return this._write(r => {\n      var s;\n      if (\"function\" == typeof e) s = e;else {\n        var i = t(e),\n          o = i.length;\n        s = function (t) {\n          for (var n = !1, r = 0; r < o; ++r) {\n            var s = i[r],\n              a = e[s];\n            b(t, s) !== a && (_(t, s, a), n = !0);\n          }\n          return n;\n        };\n      }\n      const a = n.table.core,\n        {\n          outbound: u,\n          extractKey: l\n        } = a.schema.primaryKey,\n        c = this.db._options.modifyChunkSize || 200,\n        h = [];\n      let d = 0;\n      const f = [],\n        p = (e, n) => {\n          const {\n            failures: r,\n            numFailures: s\n          } = n;\n          d += e - s;\n          for (let e of t(r)) h.push(r[e]);\n        };\n      return this.clone().primaryKeys().then(t => {\n        const i = o => {\n          const h = Math.min(c, t.length - o);\n          return a.getMany({\n            trans: r,\n            keys: t.slice(o, o + h),\n            cache: \"immutable\"\n          }).then(d => {\n            const f = [],\n              y = [],\n              m = u ? [] : null,\n              v = [];\n            for (let e = 0; e < h; ++e) {\n              const n = d[e],\n                r = {\n                  value: O(n),\n                  primKey: t[o + e]\n                };\n              !1 !== s.call(r, r.value, r) && (null == r.value ? v.push(t[o + e]) : u || 0 === $t(l(n), l(r.value)) ? (y.push(r.value), u && m.push(t[o + e])) : (v.push(t[o + e]), f.push(r.value)));\n            }\n            const g = Bt(n) && n.limit === 1 / 0 && (\"function\" != typeof e || e === Wt) && {\n              index: n.index,\n              range: n.range\n            };\n            return Promise.resolve(f.length > 0 && a.mutate({\n              trans: r,\n              type: \"add\",\n              values: f\n            }).then(e => {\n              for (let t in e.failures) v.splice(parseInt(t), 1);\n              p(f.length, e);\n            })).then(() => (y.length > 0 || g && \"object\" == typeof e) && a.mutate({\n              trans: r,\n              type: \"put\",\n              keys: m,\n              values: y,\n              criteria: g,\n              changeSpec: \"function\" != typeof e && e\n            }).then(e => p(y.length, e))).then(() => (v.length > 0 || g && e === Wt) && a.mutate({\n              trans: r,\n              type: \"delete\",\n              keys: v,\n              criteria: g\n            }).then(e => p(v.length, e))).then(() => t.length > o + h && i(o + c));\n          });\n        };\n        return i(0).then(() => {\n          if (h.length > 0) throw new z(\"Error modifying one or more objects\", h, d, f);\n          return t.length;\n        });\n      });\n    });\n  }\n  delete() {\n    var e = this._ctx,\n      t = e.range;\n    return Bt(e) && (e.isPrimKey && !kt || 3 === t.type) ? this._write(n => {\n      const {\n          primaryKey: r\n        } = e.table.core.schema,\n        s = t;\n      return e.table.core.count({\n        trans: n,\n        query: {\n          index: r,\n          range: s\n        }\n      }).then(t => e.table.core.mutate({\n        trans: n,\n        type: \"deleteRange\",\n        range: s\n      }).then(({\n        failures: e,\n        lastResult: n,\n        results: r,\n        numFailures: s\n      }) => {\n        if (s) throw new z(\"Could not delete some values\", Object.keys(e).map(t => e[t]), t - s);\n        return t - s;\n      }));\n    }) : this.modify(Wt);\n  }\n}\nconst Wt = (e, t) => t.value = null;\nfunction Yt(e, t) {\n  return e < t ? -1 : e === t ? 0 : 1;\n}\nfunction zt(e, t) {\n  return e > t ? -1 : e === t ? 0 : 1;\n}\nfunction Gt(e, t, n) {\n  var r = e instanceof en ? new e.Collection(e) : e;\n  return r._ctx.error = n ? new n(t) : new TypeError(t), r;\n}\nfunction Ht(e) {\n  return new e.Collection(e, () => Zt(\"\")).limit(0);\n}\nfunction Qt(e, t, n, r, s, i) {\n  for (var o = Math.min(e.length, r.length), a = -1, u = 0; u < o; ++u) {\n    var l = t[u];\n    if (l !== r[u]) return s(e[u], n[u]) < 0 ? e.substr(0, u) + n[u] + n.substr(u + 1) : s(e[u], r[u]) < 0 ? e.substr(0, u) + r[u] + n.substr(u + 1) : a >= 0 ? e.substr(0, a) + t[a] + n.substr(a + 1) : null;\n    s(e[u], l) < 0 && (a = u);\n  }\n  return o < r.length && \"next\" === i ? e + n.substr(e.length) : o < e.length && \"prev\" === i ? e.substr(0, n.length) : a < 0 ? null : e.substr(0, a) + r[a] + n.substr(a + 1);\n}\nfunction Xt(e, t, n, r) {\n  var s,\n    i,\n    o,\n    a,\n    u,\n    l,\n    c,\n    h = n.length;\n  if (!n.every(e => \"string\" == typeof e)) return Gt(e, bt);\n  function d(e) {\n    s = function (e) {\n      return \"next\" === e ? e => e.toUpperCase() : e => e.toLowerCase();\n    }(e), i = function (e) {\n      return \"next\" === e ? e => e.toLowerCase() : e => e.toUpperCase();\n    }(e), o = \"next\" === e ? Yt : zt;\n    var t = n.map(function (e) {\n      return {\n        lower: i(e),\n        upper: s(e)\n      };\n    }).sort(function (e, t) {\n      return o(e.lower, t.lower);\n    });\n    a = t.map(function (e) {\n      return e.upper;\n    }), u = t.map(function (e) {\n      return e.lower;\n    }), l = e, c = \"next\" === e ? \"\" : r;\n  }\n  d(\"next\");\n  var f = new e.Collection(e, () => Jt(a[0], u[h - 1] + r));\n  f._ondirectionchange = function (e) {\n    d(e);\n  };\n  var p = 0;\n  return f._addAlgorithm(function (e, n, r) {\n    var s = e.key;\n    if (\"string\" != typeof s) return !1;\n    var d = i(s);\n    if (t(d, u, p)) return !0;\n    for (var f = null, y = p; y < h; ++y) {\n      var m = Qt(s, d, a[y], u[y], o, l);\n      null === m && null === f ? p = y + 1 : (null === f || o(f, m) > 0) && (f = m);\n    }\n    return n(null !== f ? function () {\n      e.continue(f + c);\n    } : r), !1;\n  }), f;\n}\nfunction Jt(e, t, n, r) {\n  return {\n    type: 2,\n    lower: e,\n    upper: t,\n    lowerOpen: n,\n    upperOpen: r\n  };\n}\nfunction Zt(e) {\n  return {\n    type: 1,\n    lower: e,\n    upper: e\n  };\n}\nclass en {\n  get Collection() {\n    return this._ctx.table.db.Collection;\n  }\n  between(e, t, n, r) {\n    n = !1 !== n, r = !0 === r;\n    try {\n      return this._cmp(e, t) > 0 || 0 === this._cmp(e, t) && (n || r) && (!n || !r) ? Ht(this) : new this.Collection(this, () => Jt(e, t, !n, !r));\n    } catch (e) {\n      return Gt(this, gt);\n    }\n  }\n  equals(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Zt(e));\n  }\n  above(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(e, void 0, !0));\n  }\n  aboveOrEqual(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(e, void 0, !1));\n  }\n  below(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(void 0, e, !1, !0));\n  }\n  belowOrEqual(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(void 0, e));\n  }\n  startsWith(e) {\n    return \"string\" != typeof e ? Gt(this, bt) : this.between(e, e + mt, !0, !0);\n  }\n  startsWithIgnoreCase(e) {\n    return \"\" === e ? this.startsWith(e) : Xt(this, (e, t) => 0 === e.indexOf(t[0]), [e], mt);\n  }\n  equalsIgnoreCase(e) {\n    return Xt(this, (e, t) => e === t[0], [e], \"\");\n  }\n  anyOfIgnoreCase() {\n    var e = B.apply(I, arguments);\n    return 0 === e.length ? Ht(this) : Xt(this, (e, t) => -1 !== t.indexOf(e), e, \"\");\n  }\n  startsWithAnyOfIgnoreCase() {\n    var e = B.apply(I, arguments);\n    return 0 === e.length ? Ht(this) : Xt(this, (e, t) => t.some(t => 0 === e.indexOf(t)), e, mt);\n  }\n  anyOf() {\n    const e = B.apply(I, arguments);\n    let t = this._cmp;\n    try {\n      e.sort(t);\n    } catch (e) {\n      return Gt(this, gt);\n    }\n    if (0 === e.length) return Ht(this);\n    const n = new this.Collection(this, () => Jt(e[0], e[e.length - 1]));\n    n._ondirectionchange = n => {\n      t = \"next\" === n ? this._ascending : this._descending, e.sort(t);\n    };\n    let r = 0;\n    return n._addAlgorithm((n, s, i) => {\n      const o = n.key;\n      for (; t(o, e[r]) > 0;) if (++r, r === e.length) return s(i), !1;\n      return 0 === t(o, e[r]) || (s(() => {\n        n.continue(e[r]);\n      }), !1);\n    }), n;\n  }\n  notEqual(e) {\n    return this.inAnyRange([[vt, e], [e, this.db._maxKey]], {\n      includeLowers: !1,\n      includeUppers: !1\n    });\n  }\n  noneOf() {\n    const e = B.apply(I, arguments);\n    if (0 === e.length) return new this.Collection(this);\n    try {\n      e.sort(this._ascending);\n    } catch (e) {\n      return Gt(this, gt);\n    }\n    const t = e.reduce((e, t) => e ? e.concat([[e[e.length - 1][1], t]]) : [[vt, t]], null);\n    return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, {\n      includeLowers: !1,\n      includeUppers: !1\n    });\n  }\n  inAnyRange(e, t) {\n    const n = this._cmp,\n      r = this._ascending,\n      s = this._descending,\n      i = this._min,\n      o = this._max;\n    if (0 === e.length) return Ht(this);\n    if (!e.every(e => void 0 !== e[0] && void 0 !== e[1] && r(e[0], e[1]) <= 0)) return Gt(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", X.InvalidArgument);\n    const a = !t || !1 !== t.includeLowers,\n      u = t && !0 === t.includeUppers;\n    let l,\n      c = r;\n    function h(e, t) {\n      return c(e[0], t[0]);\n    }\n    try {\n      l = e.reduce(function (e, t) {\n        let r = 0,\n          s = e.length;\n        for (; r < s; ++r) {\n          const s = e[r];\n          if (n(t[0], s[1]) < 0 && n(t[1], s[0]) > 0) {\n            s[0] = i(s[0], t[0]), s[1] = o(s[1], t[1]);\n            break;\n          }\n        }\n        return r === s && e.push(t), e;\n      }, []), l.sort(h);\n    } catch (e) {\n      return Gt(this, gt);\n    }\n    let d = 0;\n    const f = u ? e => r(e, l[d][1]) > 0 : e => r(e, l[d][1]) >= 0,\n      p = a ? e => s(e, l[d][0]) > 0 : e => s(e, l[d][0]) >= 0;\n    let y = f;\n    const m = new this.Collection(this, () => Jt(l[0][0], l[l.length - 1][1], !a, !u));\n    return m._ondirectionchange = e => {\n      \"next\" === e ? (y = f, c = r) : (y = p, c = s), l.sort(h);\n    }, m._addAlgorithm((e, t, n) => {\n      for (var s = e.key; y(s);) if (++d, d === l.length) return t(n), !1;\n      return !!function (e) {\n        return !f(e) && !p(e);\n      }(s) || (0 === this._cmp(s, l[d][1]) || 0 === this._cmp(s, l[d][0]) || t(() => {\n        c === r ? e.continue(l[d][0]) : e.continue(l[d][1]);\n      }), !1);\n    }), m;\n  }\n  startsWithAnyOf() {\n    const e = B.apply(I, arguments);\n    return e.every(e => \"string\" == typeof e) ? 0 === e.length ? Ht(this) : this.inAnyRange(e.map(e => [e, e + mt])) : Gt(this, \"startsWithAnyOf() only works with strings\");\n  }\n}\nfunction tn(e) {\n  return Ye(function (t) {\n    return nn(t), e(t.target.error), !1;\n  });\n}\nfunction nn(e) {\n  e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();\n}\nconst rn = \"storagemutated\",\n  sn = \"x-storagemutated-1\",\n  on = Dt(null, rn);\nclass an {\n  _lock() {\n    return m(!Oe.global), ++this._reculock, 1 !== this._reculock || Oe.global || (Oe.lockOwnerFor = this), this;\n  }\n  _unlock() {\n    if (m(!Oe.global), 0 == --this._reculock) for (Oe.global || (Oe.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) {\n      var e = this._blockedFuncs.shift();\n      try {\n        at(e[1], e[0]);\n      } catch (e) {}\n    }\n    return this;\n  }\n  _locked() {\n    return this._reculock && Oe.lockOwnerFor !== this;\n  }\n  create(e) {\n    if (!this.mode) return this;\n    const t = this.db.idbdb,\n      n = this.db._state.dbOpenError;\n    if (m(!this.idbtrans), !e && !t) switch (n && n.name) {\n      case \"DatabaseClosedError\":\n        throw new X.DatabaseClosed(n);\n      case \"MissingAPIError\":\n        throw new X.MissingAPI(n.message, n);\n      default:\n        throw new X.OpenFailed(n);\n    }\n    if (!this.active) throw new X.TransactionInactive();\n    return m(null === this._completion._state), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }) : t.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }))).onerror = Ye(t => {\n      nn(t), this._reject(e.error);\n    }), e.onabort = Ye(t => {\n      nn(t), this.active && this._reject(new X.Abort(e.error)), this.active = !1, this.on(\"abort\").fire(t);\n    }), e.oncomplete = Ye(() => {\n      this.active = !1, this._resolve(), \"mutatedParts\" in e && on.storagemutated.fire(e.mutatedParts);\n    }), this;\n  }\n  _promise(e, t, n) {\n    if (\"readwrite\" === e && \"readwrite\" !== this.mode) return ft(new X.ReadOnly(\"Transaction is readonly\"));\n    if (!this.active) return ft(new X.TransactionInactive());\n    if (this._locked()) return new je((r, s) => {\n      this._blockedFuncs.push([() => {\n        this._promise(e, t, n).then(r, s);\n      }, Oe]);\n    });\n    if (n) return Ze(() => {\n      var e = new je((e, n) => {\n        this._lock();\n        const r = t(e, n, this);\n        r && r.then && r.then(e, n);\n      });\n      return e.finally(() => this._unlock()), e._lib = !0, e;\n    });\n    var r = new je((e, n) => {\n      var r = t(e, n, this);\n      r && r.then && r.then(e, n);\n    });\n    return r._lib = !0, r;\n  }\n  _root() {\n    return this.parent ? this.parent._root() : this;\n  }\n  waitFor(e) {\n    var t = this._root();\n    const n = je.resolve(e);\n    if (t._waitingFor) t._waitingFor = t._waitingFor.then(() => n);else {\n      t._waitingFor = n, t._waitingQueue = [];\n      var r = t.idbtrans.objectStore(t.storeNames[0]);\n      !function e() {\n        for (++t._spinCount; t._waitingQueue.length;) t._waitingQueue.shift()();\n        t._waitingFor && (r.get(-1 / 0).onsuccess = e);\n      }();\n    }\n    var s = t._waitingFor;\n    return new je((e, r) => {\n      n.then(n => t._waitingQueue.push(Ye(e.bind(null, n))), e => t._waitingQueue.push(Ye(r.bind(null, e)))).finally(() => {\n        t._waitingFor === s && (t._waitingFor = null);\n      });\n    });\n  }\n  abort() {\n    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));\n  }\n  table(e) {\n    const t = this._memoizedTables || (this._memoizedTables = {});\n    if (o(t, e)) return t[e];\n    const n = this.schema[e];\n    if (!n) throw new X.NotFound(\"Table \" + e + \" not part of transaction\");\n    const r = new this.db.Table(e, n, this);\n    return r.core = this.db.core.table(e), t[e] = r, r;\n  }\n}\nfunction un(e, t, n, r, s, i, o) {\n  return {\n    name: e,\n    keyPath: t,\n    unique: n,\n    multi: r,\n    auto: s,\n    compound: i,\n    src: (n && !o ? \"&\" : \"\") + (r ? \"*\" : \"\") + (s ? \"++\" : \"\") + ln(t)\n  };\n}\nfunction ln(e) {\n  return \"string\" == typeof e ? e : e ? \"[\" + [].join.call(e, \"+\") + \"]\" : \"\";\n}\nfunction cn(e, t, n) {\n  return {\n    name: e,\n    primKey: t,\n    indexes: n,\n    mappedClass: null,\n    idxByName: g(n, e => [e.name, e])\n  };\n}\nlet hn = e => {\n  try {\n    return e.only([[]]), hn = () => [[]], [[]];\n  } catch (e) {\n    return hn = () => mt, mt;\n  }\n};\nfunction dn(e) {\n  return null == e ? () => {} : \"string\" == typeof e ? function (e) {\n    const t = e.split(\".\");\n    return 1 === t.length ? t => t[e] : t => b(t, e);\n  }(e) : t => b(t, e);\n}\nfunction fn(e) {\n  return [].slice.call(e);\n}\nlet pn = 0;\nfunction yn(e) {\n  return null == e ? \":id\" : \"string\" == typeof e ? e : `[${e.join(\"+\")}]`;\n}\nfunction mn(e, t, r) {\n  function s(e) {\n    if (3 === e.type) return null;\n    if (4 === e.type) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    const {\n      lower: n,\n      upper: r,\n      lowerOpen: s,\n      upperOpen: i\n    } = e;\n    return void 0 === n ? void 0 === r ? null : t.upperBound(r, !!i) : void 0 === r ? t.lowerBound(n, !!s) : t.bound(n, r, !!s, !!i);\n  }\n  const {\n      schema: i,\n      hasGetAll: o\n    } = function (e, t) {\n      const r = fn(e.objectStoreNames);\n      return {\n        schema: {\n          name: e.name,\n          tables: r.map(e => t.objectStore(e)).map(e => {\n            const {\n                keyPath: t,\n                autoIncrement: r\n              } = e,\n              s = n(t),\n              i = null == t,\n              o = {},\n              a = {\n                name: e.name,\n                primaryKey: {\n                  name: null,\n                  isPrimaryKey: !0,\n                  outbound: i,\n                  compound: s,\n                  keyPath: t,\n                  autoIncrement: r,\n                  unique: !0,\n                  extractKey: dn(t)\n                },\n                indexes: fn(e.indexNames).map(t => e.index(t)).map(e => {\n                  const {\n                      name: t,\n                      unique: r,\n                      multiEntry: s,\n                      keyPath: i\n                    } = e,\n                    a = {\n                      name: t,\n                      compound: n(i),\n                      keyPath: i,\n                      unique: r,\n                      multiEntry: s,\n                      extractKey: dn(i)\n                    };\n                  return o[yn(i)] = a, a;\n                }),\n                getIndexByKeyPath: e => o[yn(e)]\n              };\n            return o[\":id\"] = a.primaryKey, null != t && (o[yn(t)] = a.primaryKey), a;\n          })\n        },\n        hasGetAll: r.length > 0 && \"getAll\" in t.objectStore(r[0]) && !(\"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n      };\n    }(e, r),\n    a = i.tables.map(e => function (e) {\n      const t = e.name;\n      return {\n        name: t,\n        schema: e,\n        mutate: function ({\n          trans: e,\n          type: n,\n          keys: r,\n          values: i,\n          range: o\n        }) {\n          return new Promise((a, u) => {\n            a = Ye(a);\n            const l = e.objectStore(t),\n              c = null == l.keyPath,\n              h = \"put\" === n || \"add\" === n;\n            if (!h && \"delete\" !== n && \"deleteRange\" !== n) throw new Error(\"Invalid operation type: \" + n);\n            const {\n              length: d\n            } = r || i || {\n              length: 1\n            };\n            if (r && i && r.length !== i.length) throw new Error(\"Given keys array must have same length as given values array.\");\n            if (0 === d) return a({\n              numFailures: 0,\n              failures: {},\n              results: [],\n              lastResult: void 0\n            });\n            let f;\n            const p = [],\n              y = [];\n            let m = 0;\n            const v = e => {\n              ++m, nn(e);\n            };\n            if (\"deleteRange\" === n) {\n              if (4 === o.type) return a({\n                numFailures: m,\n                failures: y,\n                results: [],\n                lastResult: void 0\n              });\n              3 === o.type ? p.push(f = l.clear()) : p.push(f = l.delete(s(o)));\n            } else {\n              const [e, t] = h ? c ? [i, r] : [i, null] : [r, null];\n              if (h) for (let r = 0; r < d; ++r) p.push(f = t && void 0 !== t[r] ? l[n](e[r], t[r]) : l[n](e[r])), f.onerror = v;else for (let t = 0; t < d; ++t) p.push(f = l[n](e[t])), f.onerror = v;\n            }\n            const g = e => {\n              const t = e.target.result;\n              p.forEach((e, t) => null != e.error && (y[t] = e.error)), a({\n                numFailures: m,\n                failures: y,\n                results: \"delete\" === n ? r : p.map(e => e.result),\n                lastResult: t\n              });\n            };\n            f.onerror = e => {\n              v(e), g(e);\n            }, f.onsuccess = g;\n          });\n        },\n        getMany: ({\n          trans: e,\n          keys: n\n        }) => new Promise((r, s) => {\n          r = Ye(r);\n          const i = e.objectStore(t),\n            o = n.length,\n            a = new Array(o);\n          let u,\n            l = 0,\n            c = 0;\n          const h = e => {\n              const t = e.target;\n              a[t._pos] = t.result, ++c === l && r(a);\n            },\n            d = tn(s);\n          for (let e = 0; e < o; ++e) null != n[e] && (u = i.get(n[e]), u._pos = e, u.onsuccess = h, u.onerror = d, ++l);\n          0 === l && r(a);\n        }),\n        get: ({\n          trans: e,\n          key: n\n        }) => new Promise((r, s) => {\n          r = Ye(r);\n          const i = e.objectStore(t).get(n);\n          i.onsuccess = e => r(e.target.result), i.onerror = tn(s);\n        }),\n        query: function (e) {\n          return n => new Promise((r, i) => {\n            r = Ye(r);\n            const {\n                trans: o,\n                values: a,\n                limit: u,\n                query: l\n              } = n,\n              c = u === 1 / 0 ? void 0 : u,\n              {\n                index: h,\n                range: d\n              } = l,\n              f = o.objectStore(t),\n              p = h.isPrimaryKey ? f : f.index(h.name),\n              y = s(d);\n            if (0 === u) return r({\n              result: []\n            });\n            if (e) {\n              const e = a ? p.getAll(y, c) : p.getAllKeys(y, c);\n              e.onsuccess = e => r({\n                result: e.target.result\n              }), e.onerror = tn(i);\n            } else {\n              let e = 0;\n              const t = a || !(\"openKeyCursor\" in p) ? p.openCursor(y) : p.openKeyCursor(y),\n                n = [];\n              t.onsuccess = s => {\n                const i = t.result;\n                return i ? (n.push(a ? i.value : i.primaryKey), ++e === u ? r({\n                  result: n\n                }) : void i.continue()) : r({\n                  result: n\n                });\n              }, t.onerror = tn(i);\n            }\n          });\n        }(o),\n        openCursor: function ({\n          trans: e,\n          values: n,\n          query: r,\n          reverse: i,\n          unique: o\n        }) {\n          return new Promise((a, u) => {\n            a = Ye(a);\n            const {\n                index: l,\n                range: c\n              } = r,\n              h = e.objectStore(t),\n              d = l.isPrimaryKey ? h : h.index(l.name),\n              f = i ? o ? \"prevunique\" : \"prev\" : o ? \"nextunique\" : \"next\",\n              p = n || !(\"openKeyCursor\" in d) ? d.openCursor(s(c), f) : d.openKeyCursor(s(c), f);\n            p.onerror = tn(u), p.onsuccess = Ye(t => {\n              const n = p.result;\n              if (!n) return void a(null);\n              n.___id = ++pn, n.done = !1;\n              const r = n.continue.bind(n);\n              let s = n.continuePrimaryKey;\n              s && (s = s.bind(n));\n              const i = n.advance.bind(n),\n                o = () => {\n                  throw new Error(\"Cursor not stopped\");\n                };\n              n.trans = e, n.stop = n.continue = n.continuePrimaryKey = n.advance = () => {\n                throw new Error(\"Cursor not started\");\n              }, n.fail = Ye(u), n.next = function () {\n                let e = 1;\n                return this.start(() => e-- ? this.continue() : this.stop()).then(() => this);\n              }, n.start = e => {\n                const t = new Promise((e, t) => {\n                    e = Ye(e), p.onerror = tn(t), n.fail = t, n.stop = t => {\n                      n.stop = n.continue = n.continuePrimaryKey = n.advance = o, e(t);\n                    };\n                  }),\n                  a = () => {\n                    if (p.result) try {\n                      e();\n                    } catch (e) {\n                      n.fail(e);\n                    } else n.done = !0, n.start = () => {\n                      throw new Error(\"Cursor behind last entry\");\n                    }, n.stop();\n                  };\n                return p.onsuccess = Ye(e => {\n                  p.onsuccess = a, a();\n                }), n.continue = r, n.continuePrimaryKey = s, n.advance = i, a(), t;\n              }, a(n);\n            }, u);\n          });\n        },\n        count({\n          query: e,\n          trans: n\n        }) {\n          const {\n            index: r,\n            range: i\n          } = e;\n          return new Promise((e, o) => {\n            const a = n.objectStore(t),\n              u = r.isPrimaryKey ? a : a.index(r.name),\n              l = s(i),\n              c = l ? u.count(l) : u.count();\n            c.onsuccess = Ye(t => e(t.target.result)), c.onerror = tn(o);\n          });\n        }\n      };\n    }(e)),\n    u = {};\n  return a.forEach(e => u[e.name] = e), {\n    stack: \"dbcore\",\n    transaction: e.transaction.bind(e),\n    table(e) {\n      if (!u[e]) throw new Error(`Table '${e}' not found`);\n      return u[e];\n    },\n    MIN_KEY: -1 / 0,\n    MAX_KEY: hn(t),\n    schema: i\n  };\n}\nfunction vn({\n  _novip: e\n}, t) {\n  const n = t.db,\n    r = function (e, t, {\n      IDBKeyRange: n,\n      indexedDB: r\n    }, s) {\n      const i = function (e, t) {\n        return t.reduce((e, {\n          create: t\n        }) => ({\n          ...e,\n          ...t(e)\n        }), e);\n      }(mn(t, n, s), e.dbcore);\n      return {\n        dbcore: i\n      };\n    }(e._middlewares, n, e._deps, t);\n  e.core = r.dbcore, e.tables.forEach(t => {\n    const n = t.name;\n    e.core.schema.tables.some(e => e.name === n) && (t.core = e.core.table(n), e[n] instanceof e.Table && (e[n].core = t.core));\n  });\n}\nfunction gn({\n  _novip: e\n}, t, n, r) {\n  n.forEach(n => {\n    const s = r[n];\n    t.forEach(t => {\n      const r = d(t, n);\n      (!r || \"value\" in r && void 0 === r.value) && (t === e.Transaction.prototype || t instanceof e.Transaction ? l(t, n, {\n        get() {\n          return this.table(n);\n        },\n        set(e) {\n          u(this, n, {\n            value: e,\n            writable: !0,\n            configurable: !0,\n            enumerable: !0\n          });\n        }\n      }) : t[n] = new e.Table(n, s));\n    });\n  });\n}\nfunction bn({\n  _novip: e\n}, t) {\n  t.forEach(t => {\n    for (let n in t) t[n] instanceof e.Table && delete t[n];\n  });\n}\nfunction _n(e, t) {\n  return e._cfg.version - t._cfg.version;\n}\nfunction wn(e, n, r, s) {\n  const i = e._dbSchema,\n    o = e._createTransaction(\"readwrite\", e._storeNames, i);\n  o.create(r), o._completion.catch(s);\n  const a = o._reject.bind(o),\n    u = Oe.transless || Oe;\n  Ze(() => {\n    Oe.trans = o, Oe.transless = u, 0 === n ? (t(i).forEach(e => {\n      kn(r, e, i[e].primKey, i[e].indexes);\n    }), vn(e, r), je.follow(() => e.on.populate.fire(o)).catch(a)) : function ({\n      _novip: e\n    }, n, r, s) {\n      const i = [],\n        o = e._versions;\n      let a = e._dbSchema = Pn(e, e.idbdb, s),\n        u = !1;\n      const l = o.filter(e => e._cfg.version >= n);\n      function c() {\n        return i.length ? je.resolve(i.shift()(r.idbtrans)).then(c) : je.resolve();\n      }\n      return l.forEach(o => {\n        i.push(() => {\n          const i = a,\n            l = o._cfg.dbschema;\n          Kn(e, i, s), Kn(e, l, s), a = e._dbSchema = l;\n          const c = xn(i, l);\n          c.add.forEach(e => {\n            kn(s, e[0], e[1].primKey, e[1].indexes);\n          }), c.change.forEach(e => {\n            if (e.recreate) throw new X.Upgrade(\"Not yet support for changing primary key\");\n            {\n              const t = s.objectStore(e.name);\n              e.add.forEach(e => En(t, e)), e.change.forEach(e => {\n                t.deleteIndex(e.name), En(t, e);\n              }), e.del.forEach(e => t.deleteIndex(e));\n            }\n          });\n          const h = o._cfg.contentUpgrade;\n          if (h && o._cfg.version > n) {\n            vn(e, s), r._memoizedTables = {}, u = !0;\n            let n = w(l);\n            c.del.forEach(e => {\n              n[e] = i[e];\n            }), bn(e, [e.Transaction.prototype]), gn(e, [e.Transaction.prototype], t(n), n), r.schema = n;\n            const o = T(h);\n            let a;\n            o && et();\n            const d = je.follow(() => {\n              if (a = h(r), a && o) {\n                var e = tt.bind(null, null);\n                a.then(e, e);\n              }\n            });\n            return a && \"function\" == typeof a.then ? je.resolve(a) : d.then(() => a);\n          }\n        }), i.push(t => {\n          if (!u || !xt) {\n            !function (e, t) {\n              [].slice.call(t.db.objectStoreNames).forEach(n => null == e[n] && t.db.deleteObjectStore(n));\n            }(o._cfg.dbschema, t);\n          }\n          bn(e, [e.Transaction.prototype]), gn(e, [e.Transaction.prototype], e._storeNames, e._dbSchema), r.schema = e._dbSchema;\n        });\n      }), c().then(() => {\n        var e, n;\n        n = s, t(e = a).forEach(t => {\n          n.db.objectStoreNames.contains(t) || kn(n, t, e[t].primKey, e[t].indexes);\n        });\n      });\n    }(e, n, o, r).catch(a);\n  });\n}\nfunction xn(e, t) {\n  const n = {\n    del: [],\n    add: [],\n    change: []\n  };\n  let r;\n  for (r in e) t[r] || n.del.push(r);\n  for (r in t) {\n    const s = e[r],\n      i = t[r];\n    if (s) {\n      const e = {\n        name: r,\n        def: i,\n        recreate: !1,\n        del: [],\n        add: [],\n        change: []\n      };\n      if (\"\" + (s.primKey.keyPath || \"\") != \"\" + (i.primKey.keyPath || \"\") || s.primKey.auto !== i.primKey.auto && !wt) e.recreate = !0, n.change.push(e);else {\n        const t = s.idxByName,\n          r = i.idxByName;\n        let o;\n        for (o in t) r[o] || e.del.push(o);\n        for (o in r) {\n          const n = t[o],\n            s = r[o];\n          n ? n.src !== s.src && e.change.push(s) : e.add.push(s);\n        }\n        (e.del.length > 0 || e.add.length > 0 || e.change.length > 0) && n.change.push(e);\n      }\n    } else n.add.push([r, i]);\n  }\n  return n;\n}\nfunction kn(e, t, n, r) {\n  const s = e.db.createObjectStore(t, n.keyPath ? {\n    keyPath: n.keyPath,\n    autoIncrement: n.auto\n  } : {\n    autoIncrement: n.auto\n  });\n  return r.forEach(e => En(s, e)), s;\n}\nfunction En(e, t) {\n  e.createIndex(t.name, t.keyPath, {\n    unique: t.unique,\n    multiEntry: t.multi\n  });\n}\nfunction Pn(e, t, n) {\n  const r = {};\n  return p(t.objectStoreNames, 0).forEach(e => {\n    const t = n.objectStore(e);\n    let s = t.keyPath;\n    const i = un(ln(s), s || \"\", !1, !1, !!t.autoIncrement, s && \"string\" != typeof s, !0),\n      o = [];\n    for (let e = 0; e < t.indexNames.length; ++e) {\n      const n = t.index(t.indexNames[e]);\n      s = n.keyPath;\n      var a = un(n.name, s, !!n.unique, !!n.multiEntry, !1, s && \"string\" != typeof s, !1);\n      o.push(a);\n    }\n    r[e] = cn(e, i, o);\n  }), r;\n}\nfunction Kn({\n  _novip: t\n}, n, r) {\n  const s = r.db.objectStoreNames;\n  for (let e = 0; e < s.length; ++e) {\n    const i = s[e],\n      o = r.objectStore(i);\n    t._hasGetAll = \"getAll\" in o;\n    for (let e = 0; e < o.indexNames.length; ++e) {\n      const t = o.indexNames[e],\n        r = o.index(t).keyPath,\n        s = \"string\" == typeof r ? r : \"[\" + p(r).join(\"+\") + \"]\";\n      if (n[i]) {\n        const e = n[i].idxByName[s];\n        e && (e.name = t, delete n[i].idxByName[s], n[i].idxByName[t] = e);\n      }\n    }\n  }\n  \"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604 && (t._hasGetAll = !1);\n}\nclass On {\n  _parseStoresSpec(e, r) {\n    t(e).forEach(t => {\n      if (null !== e[t]) {\n        var s = e[t].split(\",\").map((e, t) => {\n            const r = (e = e.trim()).replace(/([&*]|\\+\\+)/g, \"\"),\n              s = /^\\[/.test(r) ? r.match(/^\\[(.*)\\]$/)[1].split(\"+\") : r;\n            return un(r, s || null, /\\&/.test(e), /\\*/.test(e), /\\+\\+/.test(e), n(s), 0 === t);\n          }),\n          i = s.shift();\n        if (i.multi) throw new X.Schema(\"Primary key cannot be multi-valued\");\n        s.forEach(e => {\n          if (e.auto) throw new X.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n          if (!e.keyPath) throw new X.Schema(\"Index must have a name and cannot be an empty string\");\n        }), r[t] = cn(t, i, s);\n      }\n    });\n  }\n  stores(e) {\n    const n = this.db;\n    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, e) : e;\n    const s = n._versions,\n      i = {};\n    let o = {};\n    return s.forEach(e => {\n      r(i, e._cfg.storesSource), o = e._cfg.dbschema = {}, e._parseStoresSpec(i, o);\n    }), n._dbSchema = o, bn(n, [n._allTables, n, n.Transaction.prototype]), gn(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], t(o), o), n._storeNames = t(o), this;\n  }\n  upgrade(e) {\n    return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee, e), this;\n  }\n}\nfunction Sn(e, t) {\n  let n = e._dbNamesDB;\n  return n || (n = e._dbNamesDB = new Xn(Pt, {\n    addons: [],\n    indexedDB: e,\n    IDBKeyRange: t\n  }), n.version(1).stores({\n    dbnames: \"name\"\n  })), n.table(\"dbnames\");\n}\nfunction An(e) {\n  return e && \"function\" == typeof e.databases;\n}\nfunction Cn(e) {\n  return Ze(function () {\n    return Oe.letThrough = !0, e();\n  });\n}\nfunction jn() {\n  var e;\n  return !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function (t) {\n    var n = function () {\n      return indexedDB.databases().finally(t);\n    };\n    e = setInterval(n, 100), n();\n  }).finally(function () {\n    return clearInterval(e);\n  }) : Promise.resolve();\n}\nfunction Dn(e) {\n  const n = e._state,\n    {\n      indexedDB: r\n    } = e._deps;\n  if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(() => n.dbOpenError ? ft(n.dbOpenError) : e);\n  R && (n.openCanceller._stackHolder = q()), n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;\n  const s = n.openCanceller;\n  function i() {\n    if (n.openCanceller !== s) throw new X.DatabaseClosed(\"db.open() was cancelled\");\n  }\n  let o = n.dbReadyResolve,\n    a = null,\n    u = !1;\n  const l = () => new je((s, o) => {\n    if (i(), !r) throw new X.MissingAPI();\n    const l = e.name,\n      c = n.autoSchema ? r.open(l) : r.open(l, Math.round(10 * e.verno));\n    if (!c) throw new X.MissingAPI();\n    c.onerror = tn(o), c.onblocked = Ye(e._fireOnBlocked), c.onupgradeneeded = Ye(t => {\n      if (a = c.transaction, n.autoSchema && !e._options.allowEmptyDB) {\n        c.onerror = nn, a.abort(), c.result.close();\n        const e = r.deleteDatabase(l);\n        e.onsuccess = e.onerror = Ye(() => {\n          o(new X.NoSuchDatabase(`Database ${l} doesnt exist`));\n        });\n      } else {\n        a.onerror = tn(o);\n        var s = t.oldVersion > Math.pow(2, 62) ? 0 : t.oldVersion;\n        u = s < 1, e._novip.idbdb = c.result, wn(e, s / 10, a, o);\n      }\n    }, o), c.onsuccess = Ye(() => {\n      a = null;\n      const r = e._novip.idbdb = c.result,\n        i = p(r.objectStoreNames);\n      if (i.length > 0) try {\n        const s = r.transaction(1 === (o = i).length ? o[0] : o, \"readonly\");\n        n.autoSchema ? function ({\n          _novip: e\n        }, n, r) {\n          e.verno = n.version / 10;\n          const s = e._dbSchema = Pn(0, n, r);\n          e._storeNames = p(n.objectStoreNames, 0), gn(e, [e._allTables], t(s), s);\n        }(e, r, s) : (Kn(e, e._dbSchema, s), function (e, t) {\n          const n = xn(Pn(0, e.idbdb, t), e._dbSchema);\n          return !(n.add.length || n.change.some(e => e.add.length || e.change.length));\n        }(e, s) || console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\")), vn(e, s);\n      } catch (e) {}\n      var o;\n      _t.push(e), r.onversionchange = Ye(t => {\n        n.vcFired = !0, e.on(\"versionchange\").fire(t);\n      }), r.onclose = Ye(t => {\n        e.on(\"close\").fire(t);\n      }), u && function ({\n        indexedDB: e,\n        IDBKeyRange: t\n      }, n) {\n        !An(e) && n !== Pt && Sn(e, t).put({\n          name: n\n        }).catch(ee);\n      }(e._deps, l), s();\n    }, o);\n  }).catch(e => e && \"UnknownError\" === e.name && n.PR1398_maxLoop > 0 ? (n.PR1398_maxLoop--, console.warn(\"Dexie: Workaround for Chrome UnknownError on open()\"), l()) : je.reject(e));\n  return je.race([s, (\"undefined\" == typeof navigator ? je.resolve() : jn()).then(l)]).then(() => (i(), n.onReadyBeingFired = [], je.resolve(Cn(() => e.on.ready.fire(e.vip))).then(function t() {\n    if (n.onReadyBeingFired.length > 0) {\n      let r = n.onReadyBeingFired.reduce(ue, ee);\n      return n.onReadyBeingFired = [], je.resolve(Cn(() => r(e.vip))).then(t);\n    }\n  }))).finally(() => {\n    n.onReadyBeingFired = null, n.isBeingOpened = !1;\n  }).then(() => e).catch(t => {\n    n.dbOpenError = t;\n    try {\n      a && a.abort();\n    } catch (e) {}\n    return s === n.openCanceller && e._close(), ft(t);\n  }).finally(() => {\n    n.openComplete = !0, o();\n  });\n}\nfunction In(e) {\n  var t = t => e.next(t),\n    r = i(t),\n    s = i(t => e.throw(t));\n  function i(e) {\n    return t => {\n      var i = e(t),\n        o = i.value;\n      return i.done ? o : o && \"function\" == typeof o.then ? o.then(r, s) : n(o) ? Promise.all(o).then(r, s) : r(o);\n    };\n  }\n  return i(t)();\n}\nfunction Bn(e, t, n) {\n  var r = arguments.length;\n  if (r < 2) throw new X.InvalidArgument(\"Too few arguments\");\n  for (var s = new Array(r - 1); --r;) s[r - 1] = arguments[r];\n  return n = s.pop(), [e, k(s), n];\n}\nfunction Tn(e, t, n, r, s) {\n  return je.resolve().then(() => {\n    const i = Oe.transless || Oe,\n      o = e._createTransaction(t, n, e._dbSchema, r),\n      a = {\n        trans: o,\n        transless: i\n      };\n    if (r) o.idbtrans = r.idbtrans;else try {\n      o.create(), e._state.PR1398_maxLoop = 3;\n    } catch (r) {\n      return r.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(() => Tn(e, t, n, null, s))) : ft(r);\n    }\n    const u = T(s);\n    let l;\n    u && et();\n    const c = je.follow(() => {\n      if (l = s.call(o, o), l) if (u) {\n        var e = tt.bind(null, null);\n        l.then(e, e);\n      } else \"function\" == typeof l.next && \"function\" == typeof l.throw && (l = In(l));\n    }, a);\n    return (l && \"function\" == typeof l.then ? je.resolve(l).then(e => o.active ? e : ft(new X.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : c.then(() => l)).then(e => (r && o._resolve(), o._completion.then(() => e))).catch(e => (o._reject(e), ft(e)));\n  });\n}\nfunction Rn(e, t, r) {\n  const s = n(e) ? e.slice() : [e];\n  for (let e = 0; e < r; ++e) s.push(t);\n  return s;\n}\nconst Fn = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: function (e) {\n    return {\n      ...e,\n      table(t) {\n        const n = e.table(t),\n          {\n            schema: r\n          } = n,\n          s = {},\n          i = [];\n        function o(e, t, n) {\n          const r = yn(e),\n            a = s[r] = s[r] || [],\n            u = null == e ? 0 : \"string\" == typeof e ? 1 : e.length,\n            l = t > 0,\n            c = {\n              ...n,\n              isVirtual: l,\n              keyTail: t,\n              keyLength: u,\n              extractKey: dn(e),\n              unique: !l && n.unique\n            };\n          if (a.push(c), c.isPrimaryKey || i.push(c), u > 1) {\n            o(2 === u ? e[0] : e.slice(0, u - 1), t + 1, n);\n          }\n          return a.sort((e, t) => e.keyTail - t.keyTail), c;\n        }\n        const a = o(r.primaryKey.keyPath, 0, r.primaryKey);\n        s[\":id\"] = [a];\n        for (const e of r.indexes) o(e.keyPath, 0, e);\n        function u(t) {\n          const n = t.query.index;\n          return n.isVirtual ? {\n            ...t,\n            query: {\n              index: n,\n              range: (r = t.query.range, s = n.keyTail, {\n                type: 1 === r.type ? 2 : r.type,\n                lower: Rn(r.lower, r.lowerOpen ? e.MAX_KEY : e.MIN_KEY, s),\n                lowerOpen: !0,\n                upper: Rn(r.upper, r.upperOpen ? e.MIN_KEY : e.MAX_KEY, s),\n                upperOpen: !0\n              })\n            }\n          } : t;\n          var r, s;\n        }\n        const l = {\n          ...n,\n          schema: {\n            ...r,\n            primaryKey: a,\n            indexes: i,\n            getIndexByKeyPath: function (e) {\n              const t = s[yn(e)];\n              return t && t[0];\n            }\n          },\n          count: e => n.count(u(e)),\n          query: e => n.query(u(e)),\n          openCursor(t) {\n            const {\n              keyTail: r,\n              isVirtual: s,\n              keyLength: i\n            } = t.query.index;\n            if (!s) return n.openCursor(t);\n            return n.openCursor(u(t)).then(n => n && function (n) {\n              const s = Object.create(n, {\n                continue: {\n                  value: function (s) {\n                    null != s ? n.continue(Rn(s, t.reverse ? e.MAX_KEY : e.MIN_KEY, r)) : t.unique ? n.continue(n.key.slice(0, i).concat(t.reverse ? e.MIN_KEY : e.MAX_KEY, r)) : n.continue();\n                  }\n                },\n                continuePrimaryKey: {\n                  value(t, s) {\n                    n.continuePrimaryKey(Rn(t, e.MAX_KEY, r), s);\n                  }\n                },\n                primaryKey: {\n                  get: () => n.primaryKey\n                },\n                key: {\n                  get() {\n                    const e = n.key;\n                    return 1 === i ? e[0] : e.slice(0, i);\n                  }\n                },\n                value: {\n                  get: () => n.value\n                }\n              });\n              return s;\n            }(n));\n          }\n        };\n        return l;\n      }\n    };\n  }\n};\nfunction Mn(e, n, r, s) {\n  return r = r || {}, s = s || \"\", t(e).forEach(t => {\n    if (o(n, t)) {\n      var i = e[t],\n        a = n[t];\n      if (\"object\" == typeof i && \"object\" == typeof a && i && a) {\n        const e = C(i);\n        e !== C(a) ? r[s + t] = n[t] : \"Object\" === e ? Mn(i, a, r, s + t + \".\") : i !== a && (r[s + t] = n[t]);\n      } else i !== a && (r[s + t] = n[t]);\n    } else r[s + t] = void 0;\n  }), t(n).forEach(t => {\n    o(e, t) || (r[s + t] = n[t]);\n  }), r;\n}\nconst Nn = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: e => ({\n    ...e,\n    table(t) {\n      const n = e.table(t),\n        {\n          primaryKey: r\n        } = n.schema,\n        s = {\n          ...n,\n          mutate(e) {\n            const s = Oe.trans,\n              {\n                deleting: i,\n                creating: a,\n                updating: u\n              } = s.table(t).hook;\n            switch (e.type) {\n              case \"add\":\n                if (a.fire === ee) break;\n                return s._promise(\"readwrite\", () => l(e), !0);\n              case \"put\":\n                if (a.fire === ee && u.fire === ee) break;\n                return s._promise(\"readwrite\", () => l(e), !0);\n              case \"delete\":\n                if (i.fire === ee) break;\n                return s._promise(\"readwrite\", () => l(e), !0);\n              case \"deleteRange\":\n                if (i.fire === ee) break;\n                return s._promise(\"readwrite\", () => function (e) {\n                  return c(e.trans, e.range, 1e4);\n                }(e), !0);\n            }\n            return n.mutate(e);\n            function l(e) {\n              const t = Oe.trans,\n                s = e.keys || function (e, t) {\n                  return \"delete\" === t.type ? t.keys : t.keys || t.values.map(e.extractKey);\n                }(r, e);\n              if (!s) throw new Error(\"Keys missing\");\n              return \"delete\" !== (e = \"add\" === e.type || \"put\" === e.type ? {\n                ...e,\n                keys: s\n              } : {\n                ...e\n              }).type && (e.values = [...e.values]), e.keys && (e.keys = [...e.keys]), function (e, t, n) {\n                return \"add\" === t.type ? Promise.resolve([]) : e.getMany({\n                  trans: t.trans,\n                  keys: n,\n                  cache: \"immutable\"\n                });\n              }(n, e, s).then(l => {\n                const c = s.map((n, s) => {\n                  const c = l[s],\n                    h = {\n                      onerror: null,\n                      onsuccess: null\n                    };\n                  if (\"delete\" === e.type) i.fire.call(h, n, c, t);else if (\"add\" === e.type || void 0 === c) {\n                    const i = a.fire.call(h, n, e.values[s], t);\n                    null == n && null != i && (n = i, e.keys[s] = n, r.outbound || _(e.values[s], r.keyPath, n));\n                  } else {\n                    const r = Mn(c, e.values[s]),\n                      i = u.fire.call(h, r, n, c, t);\n                    if (i) {\n                      const t = e.values[s];\n                      Object.keys(i).forEach(e => {\n                        o(t, e) ? t[e] = i[e] : _(t, e, i[e]);\n                      });\n                    }\n                  }\n                  return h;\n                });\n                return n.mutate(e).then(({\n                  failures: t,\n                  results: n,\n                  numFailures: r,\n                  lastResult: i\n                }) => {\n                  for (let r = 0; r < s.length; ++r) {\n                    const i = n ? n[r] : s[r],\n                      o = c[r];\n                    null == i ? o.onerror && o.onerror(t[r]) : o.onsuccess && o.onsuccess(\"put\" === e.type && l[r] ? e.values[r] : i);\n                  }\n                  return {\n                    failures: t,\n                    results: n,\n                    numFailures: r,\n                    lastResult: i\n                  };\n                }).catch(e => (c.forEach(t => t.onerror && t.onerror(e)), Promise.reject(e)));\n              });\n            }\n            function c(e, t, s) {\n              return n.query({\n                trans: e,\n                values: !1,\n                query: {\n                  index: r,\n                  range: t\n                },\n                limit: s\n              }).then(({\n                result: n\n              }) => l({\n                type: \"delete\",\n                keys: n,\n                trans: e\n              }).then(r => r.numFailures > 0 ? Promise.reject(r.failures[0]) : n.length < s ? {\n                failures: [],\n                numFailures: 0,\n                lastResult: void 0\n              } : c(e, {\n                ...t,\n                lower: n[n.length - 1],\n                lowerOpen: !0\n              }, s)));\n            }\n          }\n        };\n      return s;\n    }\n  })\n};\nfunction qn(e, t, n) {\n  try {\n    if (!t) return null;\n    if (t.keys.length < e.length) return null;\n    const r = [];\n    for (let s = 0, i = 0; s < t.keys.length && i < e.length; ++s) 0 === $t(t.keys[s], e[i]) && (r.push(n ? O(t.values[s]) : t.values[s]), ++i);\n    return r.length === e.length ? r : null;\n  } catch (e) {\n    return null;\n  }\n}\nconst $n = {\n  stack: \"dbcore\",\n  level: -1,\n  create: e => ({\n    table: t => {\n      const n = e.table(t);\n      return {\n        ...n,\n        getMany: e => {\n          if (!e.cache) return n.getMany(e);\n          const t = qn(e.keys, e.trans._cache, \"clone\" === e.cache);\n          return t ? je.resolve(t) : n.getMany(e).then(t => (e.trans._cache = {\n            keys: e.keys,\n            values: \"clone\" === e.cache ? O(t) : t\n          }, t));\n        },\n        mutate: e => (\"add\" !== e.type && (e.trans._cache = null), n.mutate(e))\n      };\n    }\n  })\n};\nfunction Un(e) {\n  return !(\"from\" in e);\n}\nconst Ln = function (e, t) {\n  if (!this) {\n    const t = new Ln();\n    return e && \"d\" in e && r(t, e), t;\n  }\n  r(this, arguments.length ? {\n    d: 1,\n    from: e,\n    to: arguments.length > 1 ? t : e\n  } : {\n    d: 0\n  });\n};\nfunction Vn(e, t, n) {\n  const s = $t(t, n);\n  if (isNaN(s)) return;\n  if (s > 0) throw RangeError();\n  if (Un(e)) return r(e, {\n    from: t,\n    to: n,\n    d: 1\n  });\n  const i = e.l,\n    o = e.r;\n  if ($t(n, e.from) < 0) return i ? Vn(i, t, n) : e.l = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Gn(e);\n  if ($t(t, e.to) > 0) return o ? Vn(o, t, n) : e.r = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Gn(e);\n  $t(t, e.from) < 0 && (e.from = t, e.l = null, e.d = o ? o.d + 1 : 1), $t(n, e.to) > 0 && (e.to = n, e.r = null, e.d = e.l ? e.l.d + 1 : 1);\n  const a = !e.r;\n  i && !e.l && Wn(e, i), o && a && Wn(e, o);\n}\nfunction Wn(e, t) {\n  Un(t) || function e(t, {\n    from: n,\n    to: r,\n    l: s,\n    r: i\n  }) {\n    Vn(t, n, r), s && e(t, s), i && e(t, i);\n  }(e, t);\n}\nfunction Yn(e, t) {\n  const n = zn(t);\n  let r = n.next();\n  if (r.done) return !1;\n  let s = r.value;\n  const i = zn(e);\n  let o = i.next(s.from),\n    a = o.value;\n  for (; !r.done && !o.done;) {\n    if ($t(a.from, s.to) <= 0 && $t(a.to, s.from) >= 0) return !0;\n    $t(s.from, a.from) < 0 ? s = (r = n.next(a.from)).value : a = (o = i.next(s.from)).value;\n  }\n  return !1;\n}\nfunction zn(e) {\n  let t = Un(e) ? null : {\n    s: 0,\n    n: e\n  };\n  return {\n    next(e) {\n      const n = arguments.length > 0;\n      for (; t;) switch (t.s) {\n        case 0:\n          if (t.s = 1, n) for (; t.n.l && $t(e, t.n.from) < 0;) t = {\n            up: t,\n            n: t.n.l,\n            s: 1\n          };else for (; t.n.l;) t = {\n            up: t,\n            n: t.n.l,\n            s: 1\n          };\n        case 1:\n          if (t.s = 2, !n || $t(e, t.n.to) <= 0) return {\n            value: t.n,\n            done: !1\n          };\n        case 2:\n          if (t.n.r) {\n            t.s = 3, t = {\n              up: t,\n              n: t.n.r,\n              s: 0\n            };\n            continue;\n          }\n        case 3:\n          t = t.up;\n      }\n      return {\n        done: !0\n      };\n    }\n  };\n}\nfunction Gn(e) {\n  var t, n;\n  const r = ((null === (t = e.r) || void 0 === t ? void 0 : t.d) || 0) - ((null === (n = e.l) || void 0 === n ? void 0 : n.d) || 0),\n    s = r > 1 ? \"r\" : r < -1 ? \"l\" : \"\";\n  if (s) {\n    const t = \"r\" === s ? \"l\" : \"r\",\n      n = {\n        ...e\n      },\n      r = e[s];\n    e.from = r.from, e.to = r.to, e[s] = r[s], n[s] = r[t], e[t] = n, n.d = Hn(n);\n  }\n  e.d = Hn(e);\n}\nfunction Hn({\n  r: e,\n  l: t\n}) {\n  return (e ? t ? Math.max(e.d, t.d) : e.d : t ? t.d : 0) + 1;\n}\na(Ln.prototype, {\n  add(e) {\n    return Wn(this, e), this;\n  },\n  addKey(e) {\n    return Vn(this, e, e), this;\n  },\n  addKeys(e) {\n    return e.forEach(e => Vn(this, e, e)), this;\n  },\n  [j]() {\n    return zn(this);\n  }\n});\nconst Qn = {\n  stack: \"dbcore\",\n  level: 0,\n  create: e => {\n    const r = e.schema.name,\n      s = new Ln(e.MIN_KEY, e.MAX_KEY);\n    return {\n      ...e,\n      table: i => {\n        const o = e.table(i),\n          {\n            schema: a\n          } = o,\n          {\n            primaryKey: u\n          } = a,\n          {\n            extractKey: l,\n            outbound: c\n          } = u,\n          h = {\n            ...o,\n            mutate: e => {\n              const t = e.trans,\n                u = t.mutatedParts || (t.mutatedParts = {}),\n                l = e => {\n                  const t = `idb://${r}/${i}/${e}`;\n                  return u[t] || (u[t] = new Ln());\n                },\n                c = l(\"\"),\n                h = l(\":dels\"),\n                {\n                  type: d\n                } = e;\n              let [f, p] = \"deleteRange\" === e.type ? [e.range] : \"delete\" === e.type ? [e.keys] : e.values.length < 50 ? [[], e.values] : [];\n              const y = e.trans._cache;\n              return o.mutate(e).then(e => {\n                if (n(f)) {\n                  \"delete\" !== d && (f = e.results), c.addKeys(f);\n                  const t = qn(f, y);\n                  t || \"add\" === d || h.addKeys(f), (t || p) && function (e, t, r, s) {\n                    function i(t) {\n                      const i = e(t.name || \"\");\n                      function o(e) {\n                        return null != e ? t.extractKey(e) : null;\n                      }\n                      const a = e => t.multiEntry && n(e) ? e.forEach(e => i.addKey(e)) : i.addKey(e);\n                      (r || s).forEach((e, t) => {\n                        const n = r && o(r[t]),\n                          i = s && o(s[t]);\n                        0 !== $t(n, i) && (null != n && a(n), null != i && a(i));\n                      });\n                    }\n                    t.indexes.forEach(i);\n                  }(l, a, t, p);\n                } else if (f) {\n                  const e = {\n                    from: f.lower,\n                    to: f.upper\n                  };\n                  h.add(e), c.add(e);\n                } else c.add(s), h.add(s), a.indexes.forEach(e => l(e.name).add(s));\n                return e;\n              });\n            }\n          },\n          d = ({\n            query: {\n              index: t,\n              range: n\n            }\n          }) => {\n            var r, s;\n            return [t, new Ln(null !== (r = n.lower) && void 0 !== r ? r : e.MIN_KEY, null !== (s = n.upper) && void 0 !== s ? s : e.MAX_KEY)];\n          },\n          f = {\n            get: e => [u, new Ln(e.key)],\n            getMany: e => [u, new Ln().addKeys(e.keys)],\n            count: d,\n            query: d,\n            openCursor: d\n          };\n        return t(f).forEach(e => {\n          h[e] = function (t) {\n            const {\n              subscr: n\n            } = Oe;\n            if (n) {\n              const a = e => {\n                  const t = `idb://${r}/${i}/${e}`;\n                  return n[t] || (n[t] = new Ln());\n                },\n                u = a(\"\"),\n                h = a(\":dels\"),\n                [d, p] = f[e](t);\n              if (a(d.name || \"\").add(p), !d.isPrimaryKey) {\n                if (\"count\" !== e) {\n                  const n = \"query\" === e && c && t.values && o.query({\n                    ...t,\n                    values: !1\n                  });\n                  return o[e].apply(this, arguments).then(r => {\n                    if (\"query\" === e) {\n                      if (c && t.values) return n.then(({\n                        result: e\n                      }) => (u.addKeys(e), r));\n                      const e = t.values ? r.result.map(l) : r.result;\n                      t.values ? u.addKeys(e) : h.addKeys(e);\n                    } else if (\"openCursor\" === e) {\n                      const e = r,\n                        n = t.values;\n                      return e && Object.create(e, {\n                        key: {\n                          get: () => (h.addKey(e.primaryKey), e.key)\n                        },\n                        primaryKey: {\n                          get() {\n                            const t = e.primaryKey;\n                            return h.addKey(t), t;\n                          }\n                        },\n                        value: {\n                          get: () => (n && u.addKey(e.primaryKey), e.value)\n                        }\n                      });\n                    }\n                    return r;\n                  });\n                }\n                h.add(s);\n              }\n            }\n            return o[e].apply(this, arguments);\n          };\n        }), h;\n      }\n    };\n  }\n};\nclass Xn {\n  constructor(e, t) {\n    this._middlewares = {}, this.verno = 0;\n    const n = Xn.dependencies;\n    this._options = t = {\n      addons: Xn.addons,\n      autoOpen: !0,\n      indexedDB: n.indexedDB,\n      IDBKeyRange: n.IDBKeyRange,\n      ...t\n    }, this._deps = {\n      indexedDB: t.indexedDB,\n      IDBKeyRange: t.IDBKeyRange\n    };\n    const {\n      addons: r\n    } = t;\n    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;\n    const s = {\n      dbOpenError: null,\n      isBeingOpened: !1,\n      onReadyBeingFired: null,\n      openComplete: !1,\n      dbReadyResolve: ee,\n      dbReadyPromise: null,\n      cancelOpen: ee,\n      openCanceller: null,\n      autoSchema: !0,\n      PR1398_maxLoop: 3\n    };\n    var i;\n    s.dbReadyPromise = new je(e => {\n      s.dbReadyResolve = e;\n    }), s.openCanceller = new je((e, t) => {\n      s.cancelOpen = t;\n    }), this._state = s, this.name = e, this.on = Dt(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [ue, ee]\n    }), this.on.ready.subscribe = y(this.on.ready.subscribe, e => (t, n) => {\n      Xn.vip(() => {\n        const r = this._state;\n        if (r.openComplete) r.dbOpenError || je.resolve().then(t), n && e(t);else if (r.onReadyBeingFired) r.onReadyBeingFired.push(t), n && e(t);else {\n          e(t);\n          const r = this;\n          n || e(function e() {\n            r.on.ready.unsubscribe(t), r.on.ready.unsubscribe(e);\n          });\n        }\n      });\n    }), this.Collection = (i = this, It(Vt.prototype, function (e, t) {\n      this.db = i;\n      let n = At,\n        r = null;\n      if (t) try {\n        n = t();\n      } catch (e) {\n        r = e;\n      }\n      const s = e._ctx,\n        o = s.table,\n        a = o.hook.reading.fire;\n      this._ctx = {\n        table: o,\n        index: s.index,\n        isPrimKey: !s.index || o.schema.primKey.keyPath && s.index === o.schema.primKey.name,\n        range: n,\n        keysOnly: !1,\n        dir: \"next\",\n        unique: \"\",\n        algorithm: null,\n        filter: null,\n        replayFilter: null,\n        justLimit: !0,\n        isMatch: null,\n        offset: 0,\n        limit: 1 / 0,\n        error: r,\n        or: s.or,\n        valueMapper: a !== te ? a : null\n      };\n    })), this.Table = function (e) {\n      return It(jt.prototype, function (t, n, r) {\n        this.db = e, this._tx = r, this.name = t, this.schema = n, this.hook = e._allTables[t] ? e._allTables[t].hook : Dt(null, {\n          creating: [se, ee],\n          reading: [ne, te],\n          updating: [oe, ee],\n          deleting: [ie, ee]\n        });\n      });\n    }(this), this.Transaction = function (e) {\n      return It(an.prototype, function (t, n, r, s, i) {\n        this.db = e, this.mode = t, this.storeNames = n, this.schema = r, this.chromeTransactionDurability = s, this.idbtrans = null, this.on = Dt(this, \"complete\", \"error\", \"abort\"), this.parent = i || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new je((e, t) => {\n          this._resolve = e, this._reject = t;\n        }), this._completion.then(() => {\n          this.active = !1, this.on.complete.fire();\n        }, e => {\n          var t = this.active;\n          return this.active = !1, this.on.error.fire(e), this.parent ? this.parent._reject(e) : t && this.idbtrans && this.idbtrans.abort(), ft(e);\n        });\n      });\n    }(this), this.Version = function (e) {\n      return It(On.prototype, function (t) {\n        this.db = e, this._cfg = {\n          version: t,\n          storesSource: null,\n          dbschema: {},\n          tables: {},\n          contentUpgrade: null\n        };\n      });\n    }(this), this.WhereClause = function (e) {\n      return It(en.prototype, function (t, n, r) {\n        this.db = e, this._ctx = {\n          table: t,\n          index: \":id\" === n ? null : n,\n          or: r\n        };\n        const s = e._deps.indexedDB;\n        if (!s) throw new X.MissingAPI();\n        this._cmp = this._ascending = s.cmp.bind(s), this._descending = (e, t) => s.cmp(t, e), this._max = (e, t) => s.cmp(e, t) > 0 ? e : t, this._min = (e, t) => s.cmp(e, t) < 0 ? e : t, this._IDBKeyRange = e._deps.IDBKeyRange;\n      });\n    }(this), this.on(\"versionchange\", e => {\n      e.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();\n    }), this.on(\"blocked\", e => {\n      !e.newVersion || e.newVersion < e.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${e.oldVersion / 10}`);\n    }), this._maxKey = hn(t.IDBKeyRange), this._createTransaction = (e, t, n, r) => new this.Transaction(e, t, n, this._options.chromeTransactionDurability, r), this._fireOnBlocked = e => {\n      this.on(\"blocked\").fire(e), _t.filter(e => e.name === this.name && e !== this && !e._state.vcFired).map(t => t.on(\"versionchange\").fire(e));\n    }, this.use(Fn), this.use(Nn), this.use(Qn), this.use($n), this.vip = Object.create(this, {\n      _vip: {\n        value: !0\n      }\n    }), r.forEach(e => e(this));\n  }\n  version(e) {\n    if (isNaN(e) || e < .1) throw new X.Type(\"Given version is not a positive number\");\n    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new X.Schema(\"Cannot add version when database is open\");\n    this.verno = Math.max(this.verno, e);\n    const t = this._versions;\n    var n = t.filter(t => t._cfg.version === e)[0];\n    return n || (n = new this.Version(e), t.push(n), t.sort(_n), n.stores({}), this._state.autoSchema = !1, n);\n  }\n  _whenReady(e) {\n    return this.idbdb && (this._state.openComplete || Oe.letThrough || this._vip) ? e() : new je((e, t) => {\n      if (this._state.openComplete) return t(new X.DatabaseClosed(this._state.dbOpenError));\n      if (!this._state.isBeingOpened) {\n        if (!this._options.autoOpen) return void t(new X.DatabaseClosed());\n        this.open().catch(ee);\n      }\n      this._state.dbReadyPromise.then(e, t);\n    }).then(e);\n  }\n  use({\n    stack: e,\n    create: t,\n    level: n,\n    name: r\n  }) {\n    r && this.unuse({\n      stack: e,\n      name: r\n    });\n    const s = this._middlewares[e] || (this._middlewares[e] = []);\n    return s.push({\n      stack: e,\n      create: t,\n      level: null == n ? 10 : n,\n      name: r\n    }), s.sort((e, t) => e.level - t.level), this;\n  }\n  unuse({\n    stack: e,\n    name: t,\n    create: n\n  }) {\n    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter(e => n ? e.create !== n : !!t && e.name !== t)), this;\n  }\n  open() {\n    return Dn(this);\n  }\n  _close() {\n    const e = this._state,\n      t = _t.indexOf(this);\n    if (t >= 0 && _t.splice(t, 1), this.idbdb) {\n      try {\n        this.idbdb.close();\n      } catch (e) {}\n      this._novip.idbdb = null;\n    }\n    e.dbReadyPromise = new je(t => {\n      e.dbReadyResolve = t;\n    }), e.openCanceller = new je((t, n) => {\n      e.cancelOpen = n;\n    });\n  }\n  close() {\n    this._close();\n    const e = this._state;\n    this._options.autoOpen = !1, e.dbOpenError = new X.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);\n  }\n  delete() {\n    const e = arguments.length > 0,\n      t = this._state;\n    return new je((n, r) => {\n      const s = () => {\n        this.close();\n        var e = this._deps.indexedDB.deleteDatabase(this.name);\n        e.onsuccess = Ye(() => {\n          !function ({\n            indexedDB: e,\n            IDBKeyRange: t\n          }, n) {\n            !An(e) && n !== Pt && Sn(e, t).delete(n).catch(ee);\n          }(this._deps, this.name), n();\n        }), e.onerror = tn(r), e.onblocked = this._fireOnBlocked;\n      };\n      if (e) throw new X.InvalidArgument(\"Arguments not allowed in db.delete()\");\n      t.isBeingOpened ? t.dbReadyPromise.then(s) : s();\n    });\n  }\n  backendDB() {\n    return this.idbdb;\n  }\n  isOpen() {\n    return null !== this.idbdb;\n  }\n  hasBeenClosed() {\n    const e = this._state.dbOpenError;\n    return e && \"DatabaseClosed\" === e.name;\n  }\n  hasFailed() {\n    return null !== this._state.dbOpenError;\n  }\n  dynamicallyOpened() {\n    return this._state.autoSchema;\n  }\n  get tables() {\n    return t(this._allTables).map(e => this._allTables[e]);\n  }\n  transaction() {\n    const e = Bn.apply(this, arguments);\n    return this._transaction.apply(this, e);\n  }\n  _transaction(e, t, n) {\n    let r = Oe.trans;\n    r && r.db === this && -1 === e.indexOf(\"!\") || (r = null);\n    const s = -1 !== e.indexOf(\"?\");\n    let i, o;\n    e = e.replace(\"!\", \"\").replace(\"?\", \"\");\n    try {\n      if (o = t.map(e => {\n        var t = e instanceof this.Table ? e.name : e;\n        if (\"string\" != typeof t) throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n        return t;\n      }), \"r\" == e || e === Kt) i = Kt;else {\n        if (\"rw\" != e && e != Ot) throw new X.InvalidArgument(\"Invalid transaction mode: \" + e);\n        i = Ot;\n      }\n      if (r) {\n        if (r.mode === Kt && i === Ot) {\n          if (!s) throw new X.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n          r = null;\n        }\n        r && o.forEach(e => {\n          if (r && -1 === r.storeNames.indexOf(e)) {\n            if (!s) throw new X.SubTransaction(\"Table \" + e + \" not included in parent transaction.\");\n            r = null;\n          }\n        }), s && r && !r.active && (r = null);\n      }\n    } catch (e) {\n      return r ? r._promise(null, (t, n) => {\n        n(e);\n      }) : ft(e);\n    }\n    const a = Tn.bind(null, this, i, o, r, n);\n    return r ? r._promise(i, a, \"lock\") : Oe.trans ? at(Oe.transless, () => this._whenReady(a)) : this._whenReady(a);\n  }\n  table(e) {\n    if (!o(this._allTables, e)) throw new X.InvalidTable(`Table ${e} does not exist`);\n    return this._allTables[e];\n  }\n}\nconst Jn = \"undefined\" != typeof Symbol && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\nclass Zn {\n  constructor(e) {\n    this._subscribe = e;\n  }\n  subscribe(e, t, n) {\n    return this._subscribe(e && \"function\" != typeof e ? e : {\n      next: e,\n      error: t,\n      complete: n\n    });\n  }\n  [Jn]() {\n    return this;\n  }\n}\nfunction er(e, n) {\n  return t(n).forEach(t => {\n    Wn(e[t] || (e[t] = new Ln()), n[t]);\n  }), e;\n}\nfunction tr(e) {\n  let n,\n    r = !1;\n  const s = new Zn(s => {\n    const i = T(e);\n    let o = !1,\n      a = {},\n      u = {};\n    const l = {\n      get closed() {\n        return o;\n      },\n      unsubscribe: () => {\n        o = !0, on.storagemutated.unsubscribe(f);\n      }\n    };\n    s.start && s.start(l);\n    let c = !1,\n      h = !1;\n    function d() {\n      return t(u).some(e => a[e] && Yn(a[e], u[e]));\n    }\n    const f = e => {\n        er(a, e), d() && p();\n      },\n      p = () => {\n        if (c || o) return;\n        a = {};\n        const t = {},\n          y = function (t) {\n            i && et();\n            const n = () => Ze(e, {\n                subscr: t,\n                trans: null\n              }),\n              r = Oe.trans ? at(Oe.transless, n) : n();\n            return i && r.then(tt, tt), r;\n          }(t);\n        h || (on(rn, f), h = !0), c = !0, Promise.resolve(y).then(e => {\n          r = !0, n = e, c = !1, o || (d() ? p() : (a = {}, u = t, s.next && s.next(e)));\n        }, e => {\n          c = !1, r = !1, s.error && s.error(e), l.unsubscribe();\n        });\n      };\n    return p(), l;\n  });\n  return s.hasValue = () => r, s.getValue = () => n, s;\n}\nlet nr;\ntry {\n  nr = {\n    indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB,\n    IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange\n  };\n} catch (e) {\n  nr = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\nconst rr = Xn;\nfunction sr(e) {\n  let t = ir;\n  try {\n    ir = !0, on.storagemutated.fire(e);\n  } finally {\n    ir = t;\n  }\n}\na(rr, {\n  ...Z,\n  delete: e => new rr(e, {\n    addons: []\n  }).delete(),\n  exists: e => new rr(e, {\n    addons: []\n  }).open().then(e => (e.close(), !0)).catch(\"NoSuchDatabaseError\", () => !1),\n  getDatabaseNames(e) {\n    try {\n      return function ({\n        indexedDB: e,\n        IDBKeyRange: t\n      }) {\n        return An(e) ? Promise.resolve(e.databases()).then(e => e.map(e => e.name).filter(e => e !== Pt)) : Sn(e, t).toCollection().primaryKeys();\n      }(rr.dependencies).then(e);\n    } catch (e) {\n      return ft(new X.MissingAPI());\n    }\n  },\n  defineClass: () => function (e) {\n    r(this, e);\n  },\n  ignoreTransaction: e => Oe.trans ? at(Oe.transless, e) : e(),\n  vip: Cn,\n  async: function (e) {\n    return function () {\n      try {\n        var t = In(e.apply(this, arguments));\n        return t && \"function\" == typeof t.then ? t : je.resolve(t);\n      } catch (e) {\n        return ft(e);\n      }\n    };\n  },\n  spawn: function (e, t, n) {\n    try {\n      var r = In(e.apply(n, t || []));\n      return r && \"function\" == typeof r.then ? r : je.resolve(r);\n    } catch (e) {\n      return ft(e);\n    }\n  },\n  currentTransaction: {\n    get: () => Oe.trans || null\n  },\n  waitFor: function (e, t) {\n    const n = je.resolve(\"function\" == typeof e ? rr.ignoreTransaction(e) : e).timeout(t || 6e4);\n    return Oe.trans ? Oe.trans.waitFor(n) : n;\n  },\n  Promise: je,\n  debug: {\n    get: () => R,\n    set: e => {\n      F(e, \"dexie\" === e ? () => !0 : Et);\n    }\n  },\n  derive: c,\n  extend: r,\n  props: a,\n  override: y,\n  Events: Dt,\n  on: on,\n  liveQuery: tr,\n  extendObservabilitySet: er,\n  getByKeyPath: b,\n  setByKeyPath: _,\n  delByKeyPath: function (e, t) {\n    \"string\" == typeof t ? _(e, t, void 0) : \"length\" in t && [].map.call(t, function (t) {\n      _(e, t, void 0);\n    });\n  },\n  shallowClone: w,\n  deepClone: O,\n  getObjectDiff: Mn,\n  cmp: $t,\n  asap: v,\n  minKey: vt,\n  addons: [],\n  connections: _t,\n  errnames: H,\n  dependencies: nr,\n  semVer: yt,\n  version: yt.split(\".\").map(e => parseInt(e)).reduce((e, t, n) => e + t / Math.pow(10, 2 * n))\n}), rr.maxKey = hn(rr.dependencies.IDBKeyRange), \"undefined\" != typeof dispatchEvent && \"undefined\" != typeof addEventListener && (on(rn, e => {\n  if (!ir) {\n    let t;\n    wt ? (t = document.createEvent(\"CustomEvent\"), t.initCustomEvent(sn, !0, !0, e)) : t = new CustomEvent(sn, {\n      detail: e\n    }), ir = !0, dispatchEvent(t), ir = !1;\n  }\n}), addEventListener(sn, ({\n  detail: e\n}) => {\n  ir || sr(e);\n}));\nlet ir = !1;\nif (\"undefined\" != typeof BroadcastChannel) {\n  const e = new BroadcastChannel(sn);\n  \"function\" == typeof e.unref && e.unref(), on(rn, t => {\n    ir || e.postMessage(t);\n  }), e.onmessage = e => {\n    e.data && sr(e.data);\n  };\n} else if (\"undefined\" != typeof self && \"undefined\" != typeof navigator) {\n  on(rn, e => {\n    try {\n      ir || (\"undefined\" != typeof localStorage && localStorage.setItem(sn, JSON.stringify({\n        trig: Math.random(),\n        changedParts: e\n      })), \"object\" == typeof self.clients && [...self.clients.matchAll({\n        includeUncontrolled: !0\n      })].forEach(t => t.postMessage({\n        type: sn,\n        changedParts: e\n      })));\n    } catch (e) {}\n  }), \"undefined\" != typeof addEventListener && addEventListener(\"storage\", e => {\n    if (e.key === sn) {\n      const t = JSON.parse(e.newValue);\n      t && sr(t.changedParts);\n    }\n  });\n  const e = self.document && navigator.serviceWorker;\n  e && e.addEventListener(\"message\", function ({\n    data: e\n  }) {\n    e && e.type === sn && sr(e.changedParts);\n  });\n}\nje.rejectionMapper = function (e, t) {\n  if (!e || e instanceof W || e instanceof TypeError || e instanceof SyntaxError || !e.name || !J[e.name]) return e;\n  var n = new J[e.name](t || e.message, e);\n  return \"stack\" in e && l(n, \"stack\", {\n    get: function () {\n      return this.inner.stack;\n    }\n  }), n;\n}, F(R, Et);\nexport { Xn as Dexie, Ln as RangeSet, Xn as default, tr as liveQuery, Wn as mergeRanges, Yn as rangesOverlap };\n//# sourceMappingURL=dexie.min.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}